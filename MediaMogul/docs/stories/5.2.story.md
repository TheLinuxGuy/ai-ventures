# Story 5.2: Migration Strategy Algorithms

## Story Overview

**As a** MediaMogul user  
**I want** intelligent migration algorithms that can automatically generate optimal file organization plans based on comprehensive analysis  
**So that** I can choose from multiple migration strategies (Maximum Organization, Optimized Organization, Even-Steven, Smarter-Steven) that best fit my preferences and system characteristics

## Context

Story 5.2 implements the four core SmartMover algorithms that leverage the comprehensive analysis engine from Story 5.1. Each algorithm represents a different migration philosophy, allowing users to choose the approach that best matches their organization preferences and system constraints.

**Algorithm Overview:**
- **Maximum Organization:** Achieve perfect organization regardless of migration complexity
- **Optimized Organization:** Balance organization improvement with migration efficiency  
- **Even-Steven:** Distribute files evenly across available storage while maintaining basic organization
- **Smarter-Steven:** AI-driven algorithm that learns and adapts to user preferences over time

## Acceptance Criteria

### Algorithm Infrastructure
- [ ] **Algorithm Registry:** Pluggable algorithm system supporting multiple migration strategies
- [ ] **Strategy Selection:** Users can choose preferred algorithm with clear explanation of each approach
- [ ] **Hybrid Execution:** Support combining multiple algorithms for different file types or directories
- [ ] **Plan Validation:** All generated plans validated for feasibility and storage constraints
- [ ] **Plan Comparison:** Side-by-side comparison of different algorithm results
- [ ] **Algorithm Performance Metrics:** Track and display algorithm execution time and plan quality

### Maximum Organization Algorithm
- [ ] **Perfect Directory Structure:** Creates ideal hierarchical organization based on file metadata
- [ ] **Complete Deduplication:** Removes all duplicate files with intelligent quality-based retention
- [ ] **Comprehensive Sorting:** Sorts all files into logical categories with consistent naming
- [ ] **Quality Optimization:** Prioritizes highest quality versions and removes inferior copies
- [ ] **Metadata-Driven Organization:** Uses MediaInfo, *arr data, and file analysis for perfect categorization
- [ ] **Migration Impact Acceptance:** Willing to perform complex migrations for optimal organization

### Optimized Organization Algorithm
- [ ] **Balanced Approach:** Balances organization improvement with migration complexity
- [ ] **Incremental Improvement:** Focuses on achievable improvements without massive reorganization
- [ ] **Efficiency Prioritization:** Minimizes file moves while maximizing organization benefit
- [ ] **Selective Deduplication:** Removes obvious duplicates but preserves borderline cases
- [ ] **Performance Consideration:** Factors in disk performance and I/O optimization
- [ ] **User Preference Integration:** Adapts to learned user preferences for balanced approach

### Even-Steven Algorithm
- [ ] **Storage Balancing:** Primary focus on even distribution across available storage devices
- [ ] **Capacity Optimization:** Maximizes storage utilization while maintaining accessibility
- [ ] **Simple Organization:** Maintains basic organization structure without complex hierarchy
- [ ] **Performance Distribution:** Balances high-access files across fast storage devices
- [ ] **Growth Room Allocation:** Reserves appropriate space for future content growth
- [ ] **Network-Aware Placement:** Considers network topology for optimal access patterns

### Smarter-Steven Algorithm
- [ ] **Machine Learning Integration:** Uses AI to learn from user preferences and behavior patterns
- [ ] **Adaptive Strategy:** Dynamically adjusts approach based on user feedback and modifications
- [ ] **Preference Confidence Scoring:** Weights decisions based on confidence in user preferences
- [ ] **Behavioral Pattern Matching:** Recognizes and adapts to recurring user organization patterns
- [ ] **External Service Intelligence:** Heavily leverages *arr service data for decision making
- [ ] **Continuous Learning:** Improves recommendations based on user acceptance/rejection patterns

### Algorithm Execution Engine
- [ ] **Parallel Processing:** Execute multiple algorithms simultaneously for comparison
- [ ] **Progress Tracking:** Real-time progress updates for long-running algorithm execution
- [ ] **Memory Management:** Efficient memory usage for large library processing
- [ ] **Cancellation Support:** Allow users to cancel long-running algorithm execution
- [ ] **Partial Results:** Provide partial results if algorithm execution is interrupted
- [ ] **Result Caching:** Cache algorithm results to avoid redundant computation

### Plan Generation & Validation
- [ ] **Migration Plan Creation:** Generate detailed migration plans with file-by-file instructions
- [ ] **Constraint Validation:** Ensure all plans respect storage capacity and accessibility constraints
- [ ] **Conflict Resolution:** Handle naming conflicts and duplicate file scenarios
- [ ] **Safety Checks:** Validate plan safety with rollback capability
- [ ] **Impact Assessment:** Calculate migration impact (time, I/O, complexity) for each plan
- [ ] **Plan Optimization:** Optimize migration order for efficiency and safety

## Technical Implementation

### Algorithm Infrastructure

**SmartMover Algorithm Engine** (`internal/services/smartmover/algorithm_engine.go`)
```go
type AlgorithmEngine struct {
    analysisEngine    *AnalysisEngine
    algorithmRegistry map[string]MigrationAlgorithm
    planValidator     *PlanValidator
    progressTracker   *ProgressTracker
    logger           zerolog.Logger
    config           AlgorithmConfig
}

type MigrationAlgorithm interface {
    GetName() string
    GetDescription() string
    GetComplexityRating() ComplexityRating  // Simple, Moderate, Complex, Very Complex
    Execute(ctx context.Context, analysis *ComprehensiveAnalysis) (*MigrationPlan, error)
    ValidateConstraints(analysis *ComprehensiveAnalysis) error
    EstimateExecutionTime(analysis *ComprehensiveAnalysis) time.Duration
    GetConfigurationOptions() []ConfigurationOption
}

type MigrationPlan struct {
    PlanID               string                 `json:"plan_id"`
    AlgorithmName        string                 `json:"algorithm_name"`
    GeneratedAt          time.Time              `json:"generated_at"`
    EstimatedDuration    time.Duration          `json:"estimated_duration"`
    FilesToMove          int                    `json:"files_to_move"`
    FilesToRename        int                    `json:"files_to_rename"`
    FilesToDelete        int                    `json:"files_to_delete"`
    BytesToMove          int64                  `json:"bytes_to_move"`
    ComplexityScore      float64                `json:"complexity_score"`
    OrganizationScore    float64                `json:"organization_score"`  // Expected final organization quality
    MigrationSteps       []MigrationStep        `json:"migration_steps"`
    SafetyValidation     SafetyValidation       `json:"safety_validation"`
    ImpactAssessment     ImpactAssessment       `json:"impact_assessment"`
    PlanMetadata         map[string]interface{} `json:"plan_metadata"`
}

type MigrationStep struct {
    StepID              string            `json:"step_id"`
    StepType            string            `json:"step_type"`        // move, rename, delete, create_dir
    SourcePath          string            `json:"source_path"`
    DestinationPath     string            `json:"destination_path"`
    FileSize            int64             `json:"file_size"`
    Priority            int               `json:"priority"`         // 1=highest, 10=lowest
    Dependencies        []string          `json:"dependencies"`     // Other step IDs that must complete first
    EstimatedDuration   time.Duration     `json:"estimated_duration"`
    SafetyLevel         SafetyLevel       `json:"safety_level"`
    ValidationChecks    []ValidationCheck `json:"validation_checks"`
}

// ExecuteAlgorithm runs specific algorithm with progress tracking
func (ae *AlgorithmEngine) ExecuteAlgorithm(ctx context.Context, algorithmName string, analysis *ComprehensiveAnalysis) (*MigrationPlan, error)

// ExecuteAllAlgorithms runs all algorithms for comparison
func (ae *AlgorithmEngine) ExecuteAllAlgorithms(ctx context.Context, analysis *ComprehensiveAnalysis) (map[string]*MigrationPlan, error)

// ComparePlans provides side-by-side plan comparison
func (ae *AlgorithmEngine) ComparePlans(plans map[string]*MigrationPlan) (*PlanComparison, error)

// RegisterAlgorithm adds new algorithm to registry
func (ae *AlgorithmEngine) RegisterAlgorithm(algorithm MigrationAlgorithm) error
```

### Maximum Organization Algorithm

**Maximum Organization Implementation** (`internal/services/smartmover/algorithms/maximum_organization.go`)
```go
type MaximumOrganizationAlgorithm struct {
    fileRepo            *repositories.FileRepository
    metadataService     *services.MetadataService
    deduplicationEngine *DeduplicationEngine
    organizationRules   OrganizationRules
    logger              zerolog.Logger
}

type OrganizationRules struct {
    VideoOrganization   VideoOrganizationRules   `json:"video_organization"`
    AudioOrganization   AudioOrganizationRules   `json:"audio_organization"`
    DocumentOrganization DocumentOrganizationRules `json:"document_organization"`
    NamingConventions   NamingConventions        `json:"naming_conventions"`
    DirectoryStructure  DirectoryStructure       `json:"directory_structure"`
}

type VideoOrganizationRules struct {
    UseSeriesStructure    bool     `json:"use_series_structure"`     // TV Shows/Series Name/Season XX/episodes
    UseMovieCollections   bool     `json:"use_movie_collections"`    // Movies/Collection Name/movie files
    QualitySegregation    bool     `json:"quality_segregation"`      // Separate by resolution/quality
    YearBasedOrganization bool     `json:"year_based_organization"`  // Organize by year for movies
    GenreBasedOrganization bool    `json:"genre_based_organization"` // Secondary organization by genre
    LanguageSegregation   bool     `json:"language_segregation"`     // Separate by language
    PreferredResolutions  []string `json:"preferred_resolutions"`    // 4K, 1080p, 720p priority order
}

type DeduplicationStrategy struct {
    QualityPriority     []string  `json:"quality_priority"`      // Resolution priority order
    CodecPriority       []string  `json:"codec_priority"`        // Preferred codec order
    SourcePriority      []string  `json:"source_priority"`       // BluRay, WEB-DL, etc.
    SizeTolerance       float64   `json:"size_tolerance"`        // Size difference tolerance for duplicates
    BitratePreference   string    `json:"bitrate_preference"`    // higher, lower, balanced
    KeepMultipleVersions bool     `json:"keep_multiple_versions"` // Keep different quality versions
}

// Execute implements the Maximum Organization strategy
func (moa *MaximumOrganizationAlgorithm) Execute(ctx context.Context, analysis *ComprehensiveAnalysis) (*MigrationPlan, error) {
    plan := &MigrationPlan{
        PlanID:        uuid.New().String(),
        AlgorithmName: "Maximum Organization",
        GeneratedAt:   time.Now(),
    }

    // Phase 1: Complete deduplication with quality prioritization
    deduplicationSteps, err := moa.generateDeduplicationSteps(ctx, analysis)
    if err != nil {
        return nil, err
    }
    plan.MigrationSteps = append(plan.MigrationSteps, deduplicationSteps...)

    // Phase 2: Perfect directory structure creation
    structureSteps, err := moa.createOptimalDirectoryStructure(ctx, analysis)
    if err != nil {
        return nil, err
    }
    plan.MigrationSteps = append(plan.MigrationSteps, structureSteps...)

    // Phase 3: Metadata-driven file organization
    organizationSteps, err := moa.generateOrganizationSteps(ctx, analysis)
    if err != nil {
        return nil, err
    }
    plan.MigrationSteps = append(plan.MigrationSteps, organizationSteps...)

    // Phase 4: Consistent naming convention application
    namingSteps, err := moa.applyNamingConventions(ctx, analysis)
    if err != nil {
        return nil, err
    }
    plan.MigrationSteps = append(plan.MigrationSteps, namingSteps...)

    return moa.finalizePlan(plan, analysis)
}

// generateDeduplicationSteps creates comprehensive duplicate removal plan
func (moa *MaximumOrganizationAlgorithm) generateDeduplicationSteps(ctx context.Context, analysis *ComprehensiveAnalysis) ([]MigrationStep, error)

// createOptimalDirectoryStructure generates perfect folder hierarchy
func (moa *MaximumOrganizationAlgorithm) createOptimalDirectoryStructure(ctx context.Context, analysis *ComprehensiveAnalysis) ([]MigrationStep, error)

// generateOrganizationSteps creates metadata-driven organization plan
func (moa *MaximumOrganizationAlgorithm) generateOrganizationSteps(ctx context.Context, analysis *ComprehensiveAnalysis) ([]MigrationStep, error)

// applyNamingConventions ensures consistent file naming
func (moa *MaximumOrganizationAlgorithm) applyNamingConventions(ctx context.Context, analysis *ComprehensiveAnalysis) ([]MigrationStep, error)
```

### Optimized Organization Algorithm

**Optimized Organization Implementation** (`internal/services/smartmover/algorithms/optimized_organization.go`)
```go
type OptimizedOrganizationAlgorithm struct {
    fileRepo              *repositories.FileRepository
    migrationAnalyzer     *MigrationAnalyzer
    efficiencyCalculator  *EfficiencyCalculator
    userPreferenceService *services.UserPreferenceService
    logger               zerolog.Logger
}

type OptimizationStrategy struct {
    MaxMigrationComplexity  ComplexityRating     `json:"max_migration_complexity"`
    EfficiencyThreshold     float64              `json:"efficiency_threshold"`      // Minimum benefit/cost ratio
    PreserveUserStructure   bool                 `json:"preserve_user_structure"`   // Respect existing organization
    IncrementalImprovement  bool                 `json:"incremental_improvement"`   // Make gradual improvements
    PerformancePriority     PerformancePriority  `json:"performance_priority"`
    DeduplicationAggressiveness string           `json:"deduplication_aggressiveness"` // conservative, moderate, aggressive
}

type EfficiencyMetrics struct {
    OrganizationImprovement float64   `json:"organization_improvement"`  // 0.0 to 1.0
    MigrationComplexity     float64   `json:"migration_complexity"`      // 0.0 to 1.0  
    TimeEfficiency          float64   `json:"time_efficiency"`           // Expected time savings
    StorageEfficiency       float64   `json:"storage_efficiency"`        // Space optimization
    UserSatisfactionScore   float64   `json:"user_satisfaction_score"`   // Predicted user satisfaction
    BenefitCostRatio        float64   `json:"benefit_cost_ratio"`        // Overall efficiency metric
}

// Execute implements the Optimized Organization strategy
func (ooa *OptimizedOrganizationAlgorithm) Execute(ctx context.Context, analysis *ComprehensiveAnalysis) (*MigrationPlan, error) {
    plan := &MigrationPlan{
        PlanID:        uuid.New().String(),
        AlgorithmName: "Optimized Organization",
        GeneratedAt:   time.Now(),
    }

    // Phase 1: Analyze current organization efficiency
    efficiencyAnalysis, err := ooa.analyzeCurrentEfficiency(ctx, analysis)
    if err != nil {
        return nil, err
    }

    // Phase 2: Identify high-impact, low-cost improvements
    improvements, err := ooa.identifyOptimalImprovements(ctx, analysis, efficiencyAnalysis)
    if err != nil {
        return nil, err
    }

    // Phase 3: Selective deduplication based on clear benefits
    deduplicationSteps, err := ooa.generateSelectiveDeduplication(ctx, analysis)
    if err != nil {
        return nil, err
    }
    plan.MigrationSteps = append(plan.MigrationSteps, deduplicationSteps...)

    // Phase 4: Performance-aware organization improvements
    organizationSteps, err := ooa.generateEfficiencyOptimizedSteps(ctx, improvements)
    if err != nil {
        return nil, err
    }
    plan.MigrationSteps = append(plan.MigrationSteps, organizationSteps...)

    return ooa.finalizePlan(plan, analysis, efficiencyAnalysis)
}

// analyzeCurrentEfficiency evaluates existing organization effectiveness
func (ooa *OptimizedOrganizationAlgorithm) analyzeCurrentEfficiency(ctx context.Context, analysis *ComprehensiveAnalysis) (*EfficiencyMetrics, error)

// identifyOptimalImprovements finds high-benefit, low-cost organization changes
func (ooa *OptimizedOrganizationAlgorithm) identifyOptimalImprovements(ctx context.Context, analysis *ComprehensiveAnalysis, efficiency *EfficiencyMetrics) ([]OrganizationImprovement, error)

// generateSelectiveDeduplication creates targeted duplicate removal plan
func (ooa *OptimizedOrganizationAlgorithm) generateSelectiveDeduplication(ctx context.Context, analysis *ComprehensiveAnalysis) ([]MigrationStep, error)

// calculateEfficiencyScore computes benefit/cost ratio for potential changes
func (ooa *OptimizedOrganizationAlgorithm) calculateEfficiencyScore(ctx context.Context, change *OrganizationImprovement) (float64, error)
```

### Even-Steven Algorithm

**Even-Steven Implementation** (`internal/services/smartmover/algorithms/even_steven.go`)
```go
type EvenStevenAlgorithm struct {
    storageAnalyzer      *StorageAnalyzer
    distributionEngine   *DistributionEngine
    performanceProfiler  *PerformanceProfiler
    capacityCalculator   *CapacityCalculator
    logger              zerolog.Logger
}

type DistributionStrategy struct {
    BalancingMethod       BalancingMethod      `json:"balancing_method"`         // capacity, usage, performance
    GrowthReservation     float64             `json:"growth_reservation"`       // Percentage of space to reserve
    PerformanceTiering    bool                `json:"performance_tiering"`      // Separate by disk performance
    AccessPatternAware    bool                `json:"access_pattern_aware"`     // Consider file access frequency
    RedundancyLevel       RedundancyLevel     `json:"redundancy_level"`         // none, basic, full
    NetworkOptimization   bool                `json:"network_optimization"`     // Consider network topology
}

type StorageDistributionPlan struct {
    DiskAllocations       []DiskAllocation     `json:"disk_allocations"`
    BalanceMetrics        BalanceMetrics       `json:"balance_metrics"`
    PerformanceOptimization PerformanceOptimization `json:"performance_optimization"`
    GrowthProjections     GrowthProjections    `json:"growth_projections"`
    RedundancyStrategy    RedundancyStrategy   `json:"redundancy_strategy"`
}

type DiskAllocation struct {
    DiskID               string               `json:"disk_id"`
    DiskPath             string               `json:"disk_path"`
    CurrentUtilization   float64              `json:"current_utilization"`
    TargetUtilization    float64              `json:"target_utilization"`
    FilesToAllocate      []FileAllocation     `json:"files_to_allocate"`
    PerformanceTier      PerformanceTier      `json:"performance_tier"`
    ExpectedGrowth       int64                `json:"expected_growth"`          // bytes
    BalanceScore         float64              `json:"balance_score"`            // 0.0 to 1.0
}

// Execute implements the Even-Steven distribution strategy
func (esa *EvenStevenAlgorithm) Execute(ctx context.Context, analysis *ComprehensiveAnalysis) (*MigrationPlan, error) {
    plan := &MigrationPlan{
        PlanID:        uuid.New().String(),
        AlgorithmName: "Even-Steven",
        GeneratedAt:   time.Now(),
    }

    // Phase 1: Analyze current storage distribution
    distributionAnalysis, err := esa.analyzeCurrentDistribution(ctx, analysis)
    if err != nil {
        return nil, err
    }

    // Phase 2: Calculate optimal distribution targets
    targetDistribution, err := esa.calculateOptimalDistribution(ctx, analysis)
    if err != nil {
        return nil, err
    }

    // Phase 3: Generate rebalancing migration steps
    rebalancingSteps, err := esa.generateRebalancingSteps(ctx, distributionAnalysis, targetDistribution)
    if err != nil {
        return nil, err
    }
    plan.MigrationSteps = append(plan.MigrationSteps, rebalancingSteps...)

    // Phase 4: Apply performance-aware placement
    performanceSteps, err := esa.optimizePerformancePlacement(ctx, analysis, targetDistribution)
    if err != nil {
        return nil, err
    }
    plan.MigrationSteps = append(plan.MigrationSteps, performanceSteps...)

    // Phase 5: Reserve space for future growth
    growthSteps, err := esa.reserveGrowthCapacity(ctx, targetDistribution)
    if err != nil {
        return nil, err
    }
    plan.MigrationSteps = append(plan.MigrationSteps, growthSteps...)

    return esa.finalizePlan(plan, distributionAnalysis, targetDistribution)
}

// analyzeCurrentDistribution evaluates existing storage balance
func (esa *EvenStevenAlgorithm) analyzeCurrentDistribution(ctx context.Context, analysis *ComprehensiveAnalysis) (*StorageDistributionPlan, error)

// calculateOptimalDistribution determines ideal file placement targets
func (esa *EvenStevenAlgorithm) calculateOptimalDistribution(ctx context.Context, analysis *ComprehensiveAnalysis) (*StorageDistributionPlan, error)

// generateRebalancingSteps creates file moves for better distribution
func (esa *EvenStevenAlgorithm) generateRebalancingSteps(ctx context.Context, current, target *StorageDistributionPlan) ([]MigrationStep, error)

// calculateBalanceScore evaluates how evenly distributed files are across storage
func (esa *EvenStevenAlgorithm) calculateBalanceScore(allocations []DiskAllocation) float64
```

### Smarter-Steven Algorithm

**Smarter-Steven Implementation** (`internal/services/smartmover/algorithms/smarter_steven.go`)
```go
type SmarterStevenAlgorithm struct {
    machineLearningEngine *MachineLearningEngine
    patternRecognition    *PatternRecognition
    userBehaviorAnalyzer  *UserBehaviorAnalyzer
    adaptationEngine      *AdaptationEngine
    confidenceCalculator  *ConfidenceCalculator
    logger               zerolog.Logger
}

type LearningStrategy struct {
    UserPreferenceWeight    float64              `json:"user_preference_weight"`
    BehavioralPatternWeight float64              `json:"behavioral_pattern_weight"`
    ExternalServiceWeight   float64              `json:"external_service_weight"`
    SystemOptimizationWeight float64             `json:"system_optimization_weight"`
    AdaptationRate          float64              `json:"adaptation_rate"`           // How quickly to adapt to new patterns
    ConfidenceThreshold     float64              `json:"confidence_threshold"`      // Minimum confidence for decisions
    LearningDecayRate       float64              `json:"learning_decay_rate"`       // How old patterns lose relevance
}

type IntelligentDecision struct {
    Decision             string                `json:"decision"`
    DecisionType         DecisionType          `json:"decision_type"`
    Confidence           float64               `json:"confidence"`
    ReasoningChain       []ReasoningStep       `json:"reasoning_chain"`
    LearningSources      []string              `json:"learning_sources"`
    SupportingEvidence   []Evidence            `json:"supporting_evidence"`
    AlternativeOptions   []Alternative         `json:"alternative_options"`
    RiskAssessment       RiskAssessment        `json:"risk_assessment"`
}

type AdaptivePattern struct {
    PatternID           string                 `json:"pattern_id"`
    PatternType         string                 `json:"pattern_type"`        // organization, naming, quality, placement
    PatternDescription  string                 `json:"pattern_description"`
    Confidence          float64                `json:"confidence"`
    ObservationCount    int                    `json:"observation_count"`
    LastObserved        time.Time              `json:"last_observed"`
    SuccessRate         float64                `json:"success_rate"`        // User acceptance rate
    Context             map[string]interface{} `json:"context"`             // When pattern applies
    Evolution           PatternEvolution       `json:"evolution"`           // How pattern has changed
}

// Execute implements the Smarter-Steven AI-driven strategy
func (ssa *SmarterStevenAlgorithm) Execute(ctx context.Context, analysis *ComprehensiveAnalysis) (*MigrationPlan, error) {
    plan := &MigrationPlan{
        PlanID:        uuid.New().String(),
        AlgorithmName: "Smarter-Steven",
        GeneratedAt:   time.Now(),
    }

    // Phase 1: Learn from comprehensive user behavior and preferences
    learningResults, err := ssa.performComprehensiveLearning(ctx, analysis)
    if err != nil {
        return nil, err
    }

    // Phase 2: Generate AI-driven organization decisions
    intelligentDecisions, err := ssa.generateIntelligentDecisions(ctx, analysis, learningResults)
    if err != nil {
        return nil, err
    }

    // Phase 3: Create adaptive migration plan based on learned patterns
    adaptivePlan, err := ssa.createAdaptiveMigrationPlan(ctx, intelligentDecisions)
    if err != nil {
        return nil, err
    }
    plan.MigrationSteps = append(plan.MigrationSteps, adaptivePlan.Steps...)

    // Phase 4: Apply continuous learning adjustments
    adjustedPlan, err := ssa.applyContinuousLearningAdjustments(ctx, plan, learningResults)
    if err != nil {
        return nil, err
    }

    // Phase 5: Generate confidence-weighted recommendations
    finalPlan, err := ssa.generateConfidenceWeightedPlan(ctx, adjustedPlan, intelligentDecisions)
    if err != nil {
        return nil, err
    }

    return ssa.finalizePlan(finalPlan, learningResults, intelligentDecisions)
}

// performComprehensiveLearning analyzes all available data to extract patterns
func (ssa *SmarterStevenAlgorithm) performComprehensiveLearning(ctx context.Context, analysis *ComprehensiveAnalysis) (*LearningResults, error)

// generateIntelligentDecisions creates AI-driven organization decisions with reasoning
func (ssa *SmarterStevenAlgorithm) generateIntelligentDecisions(ctx context.Context, analysis *ComprehensiveAnalysis, learning *LearningResults) ([]*IntelligentDecision, error)

// createAdaptiveMigrationPlan builds plan that adapts to learned user preferences
func (ssa *SmarterStevenAlgorithm) createAdaptiveMigrationPlan(ctx context.Context, decisions []*IntelligentDecision) (*AdaptiveMigrationPlan, error)

// learnFromUserFeedback updates algorithm based on user plan modifications
func (ssa *SmarterStevenAlgorithm) learnFromUserFeedback(ctx context.Context, originalPlan, modifiedPlan *MigrationPlan) error
```

### Plan Validation & Comparison

**Plan Validator** (`internal/services/smartmover/plan_validator.go`)
```go
type PlanValidator struct {
    storageValidator     *StorageValidator
    safetyValidator      *SafetyValidator
    performanceValidator *PerformanceValidator
    conflictResolver     *ConflictResolver
    logger              zerolog.Logger
}

type SafetyValidation struct {
    ValidationScore      float64              `json:"validation_score"`      // 0.0 to 1.0
    SafetyChecks         []SafetyCheck        `json:"safety_checks"`
    RiskAssessment       RiskAssessment       `json:"risk_assessment"`
    RollbackCapability   bool                 `json:"rollback_capability"`
    RequiredBackups      []string             `json:"required_backups"`
    ValidationWarnings   []ValidationWarning  `json:"validation_warnings"`
    BlockingIssues       []BlockingIssue      `json:"blocking_issues"`
}

type PlanComparison struct {
    ComparisonID         string               `json:"comparison_id"`
    Plans                map[string]*MigrationPlan `json:"plans"`
    ComparisonMetrics    ComparisonMetrics    `json:"comparison_metrics"`
    Recommendations      []ComparisonRecommendation `json:"recommendations"`
    UserGuideToSelection UserGuideToSelection `json:"user_guide_to_selection"`
}

type ComparisonMetrics struct {
    OrganizationImprovement map[string]float64 `json:"organization_improvement"`
    MigrationComplexity     map[string]float64 `json:"migration_complexity"`
    EstimatedDuration       map[string]time.Duration `json:"estimated_duration"`
    RiskLevel              map[string]RiskLevel `json:"risk_level"`
    StorageEfficiency      map[string]float64   `json:"storage_efficiency"`
    UserSuitabilityScore   map[string]float64   `json:"user_suitability_score"`
}

// ValidatePlan performs comprehensive plan validation
func (pv *PlanValidator) ValidatePlan(ctx context.Context, plan *MigrationPlan, analysis *ComprehensiveAnalysis) (*SafetyValidation, error)

// ComparePlans provides detailed comparison of multiple migration plans
func (pv *PlanValidator) ComparePlans(plans map[string]*MigrationPlan, analysis *ComprehensiveAnalysis) (*PlanComparison, error)

// ValidateStorageConstraints ensures plan respects storage limitations
func (pv *PlanValidator) ValidateStorageConstraints(ctx context.Context, plan *MigrationPlan) error

// GenerateUserGuide creates guidance for plan selection
func (pv *PlanValidator) GenerateUserGuide(comparison *PlanComparison, userPreferences *UserIntelligence) (*UserGuideToSelection, error)
```

## Database Schema

**Migration Planning Tables** (`migrations/015_smartmover_algorithms.sql`)
```sql
CREATE TABLE smartmover_migration_plans (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    algorithm_name TEXT NOT NULL,
    plan_version INTEGER NOT NULL DEFAULT 1,
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'validated', 'approved', 'executing', 'completed', 'cancelled')),
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    estimated_duration_minutes INTEGER,
    files_to_move INTEGER NOT NULL DEFAULT 0,
    files_to_rename INTEGER NOT NULL DEFAULT 0,
    files_to_delete INTEGER NOT NULL DEFAULT 0,
    bytes_to_move INTEGER NOT NULL DEFAULT 0,
    complexity_score REAL NOT NULL DEFAULT 0.5,
    organization_score REAL NOT NULL DEFAULT 0.5,
    plan_data TEXT NOT NULL,               -- JSON migration plan details
    validation_data TEXT,                  -- JSON validation results
    user_modifications TEXT DEFAULT '[]', -- JSON array of user changes
    execution_progress REAL DEFAULT 0.0,  -- Execution progress 0.0 to 1.0
    analysis_id TEXT,                     -- Reference to analysis used
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (analysis_id) REFERENCES smartmover_analyses(id)
);

CREATE INDEX idx_migration_plans_user_id ON smartmover_migration_plans(user_id);
CREATE INDEX idx_migration_plans_algorithm ON smartmover_migration_plans(algorithm_name);
CREATE INDEX idx_migration_plans_status ON smartmover_migration_plans(status);
CREATE INDEX idx_migration_plans_created_at ON smartmover_migration_plans(created_at);

CREATE TABLE smartmover_algorithm_performance (
    id TEXT PRIMARY KEY,
    algorithm_name TEXT NOT NULL,
    analysis_type TEXT NOT NULL,
    library_size_category TEXT NOT NULL,    -- small, medium, large, enterprise
    execution_time_ms INTEGER NOT NULL,
    memory_usage_mb INTEGER,
    plan_quality_score REAL,
    user_satisfaction_score REAL,
    success_rate REAL DEFAULT 1.0,
    recorded_at INTEGER NOT NULL
);

CREATE INDEX idx_algorithm_performance_name ON smartmover_algorithm_performance(algorithm_name);
CREATE INDEX idx_algorithm_performance_recorded_at ON smartmover_algorithm_performance(recorded_at);

CREATE TABLE smartmover_learned_patterns (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    pattern_type TEXT NOT NULL,             -- organization, naming, quality, placement, distribution
    pattern_data TEXT NOT NULL,            -- JSON pattern details
    confidence REAL NOT NULL DEFAULT 0.5 CHECK (confidence >= 0.0 AND confidence <= 1.0),
    observation_count INTEGER NOT NULL DEFAULT 1,
    success_rate REAL NOT NULL DEFAULT 1.0,
    last_observed_at INTEGER NOT NULL,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    context_data TEXT DEFAULT '{}',        -- JSON context when pattern applies
    FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_learned_patterns_user_id ON smartmover_learned_patterns(user_id);
CREATE INDEX idx_learned_patterns_type ON smartmover_learned_patterns(pattern_type);
CREATE INDEX idx_learned_patterns_confidence ON smartmover_learned_patterns(confidence);
```

## API Endpoints

### Algorithm Execution
```
POST   /api/v1/smartmover/algorithms/execute/{algorithm}     # Execute specific algorithm
POST   /api/v1/smartmover/algorithms/execute-all             # Execute all algorithms for comparison
GET    /api/v1/smartmover/algorithms                         # List available algorithms with descriptions
GET    /api/v1/smartmover/algorithms/{algorithm}/config      # Get algorithm configuration options
PUT    /api/v1/smartmover/algorithms/{algorithm}/config      # Update algorithm configuration
```

### Plan Management
```
GET    /api/v1/smartmover/plans                              # List user's migration plans
GET    /api/v1/smartmover/plans/{plan_id}                    # Get specific migration plan
POST   /api/v1/smartmover/plans/{plan_id}/validate           # Validate migration plan
POST   /api/v1/smartmover/plans/{plan_id}/approve            # Approve plan for execution
PUT    /api/v1/smartmover/plans/{plan_id}                    # Modify migration plan
DELETE /api/v1/smartmover/plans/{plan_id}                    # Delete migration plan
POST   /api/v1/smartmover/plans/compare                      # Compare multiple plans
```

### Algorithm Intelligence
```
GET    /api/v1/smartmover/patterns                           # Get learned patterns
GET    /api/v1/smartmover/patterns/{user_id}                 # Get user-specific patterns
POST   /api/v1/smartmover/patterns/learn                     # Record new learning event
GET    /api/v1/smartmover/algorithms/performance             # Get algorithm performance metrics
POST   /api/v1/smartmover/algorithms/feedback                # Submit feedback on algorithm results
```

### Plan Execution
```
POST   /api/v1/smartmover/plans/{plan_id}/execute            # Start plan execution
GET    /api/v1/smartmover/plans/{plan_id}/progress           # Get execution progress
POST   /api/v1/smartmover/plans/{plan_id}/pause              # Pause plan execution
POST   /api/v1/smartmover/plans/{plan_id}/resume             # Resume plan execution
POST   /api/v1/smartmover/plans/{plan_id}/cancel             # Cancel plan execution
```

## Frontend Implementation

### Algorithm Selection Interface
**Algorithm Selection Component** (`components/smartmover/AlgorithmSelection.tsx`)
- Algorithm comparison cards with visual descriptions
- Configuration options for each algorithm
- Preview of expected outcomes and complexity
- User preference integration and recommendations
- Side-by-side algorithm comparison

### Migration Plan Viewer
**Plan Viewer Component** (`components/smartmover/PlanViewer.tsx`)
- Detailed migration plan visualization
- File-by-file migration steps with progress tracking
- Plan modification interface with impact assessment
- Safety validation results and warnings display
- Plan comparison interface with recommendation engine

### Algorithm Performance Dashboard
**Performance Dashboard** (`components/smartmover/AlgorithmPerformance.tsx`)
- Algorithm execution time and quality metrics
- User satisfaction tracking and feedback interface
- Learning pattern visualization and confidence scores
- Historical performance trends and optimization suggestions
- Success rate monitoring and algorithm recommendation

## Validation & Testing

### Algorithm Testing
- [ ] Algorithm correctness across different library types and sizes
- [ ] Plan generation performance for large libraries (100k+ files)
- [ ] Memory usage optimization during complex plan generation
- [ ] Algorithm comparison accuracy and user guidance quality
- [ ] Machine learning integration and adaptive improvement validation

### Plan Validation Testing
- [ ] Storage constraint validation accuracy
- [ ] Safety check comprehensiveness and risk assessment
- [ ] Conflict resolution effectiveness for complex scenarios
- [ ] Rollback capability testing and data integrity assurance
- [ ] Performance impact assessment accuracy

### Integration Testing
- [ ] End-to-end algorithm execution with analysis engine integration
- [ ] User preference learning and adaptation effectiveness
- [ ] External service intelligence integration in decision making
- [ ] Cross-algorithm consistency and comparison reliability
- [ ] Plan modification and re-validation functionality

### Performance Testing
- [ ] Large library algorithm execution (500k+ files)
- [ ] Concurrent algorithm execution for plan comparison
- [ ] Memory efficiency during complex plan generation
- [ ] Database performance with large migration plans
- [ ] Real-time progress tracking accuracy and responsiveness

## Dependencies

**Required Stories:**
- Story 5.1: SmartMover Analysis Engine Foundation (comprehensive analysis capabilities)
- Epic 4: External Services Integration (Sonarr/Radarr data for intelligent decisions)
- Epic 3: Migration Infrastructure (migration execution capabilities)
- Epic 2: Task Engine (background processing for plan generation)

**Technical Dependencies:**
- Machine learning libraries for pattern recognition and adaptive algorithms
- Advanced file metadata analysis capabilities
- User behavior tracking and preference inference systems
- System performance monitoring and optimization tools

## Definition of Done

- [ ] Four complete migration algorithms with distinct strategies and capabilities
- [ ] Algorithm execution engine with parallel processing and comparison features
- [ ] Comprehensive plan validation with safety checks and risk assessment
- [ ] User behavior learning integration with confidence-based decision making
- [ ] Plan comparison interface with detailed metrics and user guidance
- [ ] Database schema supporting complex migration plans and learned patterns
- [ ] Complete API endpoints for algorithm execution and plan management
- [ ] Frontend components for algorithm selection and plan visualization
- [ ] Machine learning integration for adaptive algorithm improvement
- [ ] Performance optimization for large library processing

## Success Metrics

- **Algorithm Quality:** 90%+ user satisfaction with generated migration plans
- **Performance:** Generate complete migration plans for 100k files in under 2 minutes
- **Learning Effectiveness:** Measurable improvement in plan acceptance rate over time
- **Safety:** 99.9%+ plan validation accuracy with zero data loss incidents
- **Adaptability:** Algorithm recommendations improve 25%+ with user feedback integration
- **Scalability:** Support migration planning for libraries up to 1M files

## Next Stories

This story enables:
- **Story 5.3:** SmartMover User Interface & Integration (comprehensive UI for algorithm selection and plan management)
- **Future Enhancement:** Advanced AI/ML integration for even more intelligent automation

## PRD Requirements Fulfilled

- **Automated Migration Planning:** Four distinct algorithms providing comprehensive automation options
- **User Choice and Control:** Multiple algorithms allowing users to choose their preferred approach
- **Intelligent Adaptation:** Machine learning integration that improves recommendations over time
- **Safety and Reliability:** Comprehensive plan validation with safety checks and rollback capability
- **Performance Optimization:** Efficient algorithms supporting large-scale library processing
- **Integration Excellence:** Seamless integration with analysis engine and external service data


## File List

*To be populated during implementation*

## Dev Agent Record

### Implementation Notes
*To be populated during development*

### Completion Notes
*To be populated upon completion*

### Debug Log References
*To be populated if debugging required*

## QA Results

*To be populated during QA review*
