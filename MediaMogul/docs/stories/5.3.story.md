# Story 5.3: SmartMover User Interface & Integration

## Story Overview

**As a** MediaMogul user  
**I want** an intuitive and comprehensive SmartMover interface that seamlessly integrates analysis insights, algorithm selection, plan visualization, and migration execution  
**So that** I can easily leverage automated migration planning with full transparency, control, and confidence in the system's recommendations

## Context

Story 5.3 completes Epic 5 by implementing the comprehensive user interface that brings together the analysis engine (Story 5.1) and migration algorithms (Story 5.2) into a cohesive, user-friendly experience. This story focuses on making the powerful SmartMover automation accessible and transparent to users through intuitive interfaces, clear visualizations, and seamless workflow integration.

**User Experience Goals:**
- **Transparency:** Clear visualization of analysis results and algorithm reasoning
- **Control:** Full user control over algorithm selection and plan modification
- **Confidence:** Build user trust through comprehensive explanation and validation
- **Efficiency:** Streamlined workflows that minimize user effort while maximizing insight

## Acceptance Criteria

### SmartMover Dashboard & Overview
- [ ] **Central SmartMover Hub:** Unified dashboard showing analysis status, recent migrations, and recommended actions
- [ ] **Library Health Overview:** Visual summary of library organization quality, duplicate status, and optimization opportunities
- [ ] **Quick Action Cards:** One-click access to common SmartMover operations (analyze, generate plans, execute migrations)
- [ ] **Progress Tracking:** Real-time visibility into ongoing analysis and migration operations
- [ ] **Intelligence Insights Panel:** Highlight key insights from analysis engine with actionable recommendations
- [ ] **Historical Migration Tracking:** Timeline view of previous SmartMover operations with success metrics

### Analysis Results Visualization
- [ ] **Comprehensive Analysis Dashboard:** Multi-tab interface showing Library, External, User, and System intelligence results
- [ ] **Interactive Data Visualizations:** Charts and graphs showing content distribution, organization patterns, quality analysis
- [ ] **Pattern Recognition Display:** Visual representation of detected organization patterns and naming conventions
- [ ] **Duplicate Analysis Viewer:** Detailed duplicate file visualization with quality comparison and removal recommendations
- [ ] **Optimization Opportunities Explorer:** Prioritized list of improvement opportunities with impact estimates
- [ ] **Confidence Indicators:** Clear display of analysis confidence levels with explanation of certainty factors

### Algorithm Selection & Configuration
- [ ] **Algorithm Comparison Interface:** Side-by-side comparison of all four SmartMover algorithms with pros/cons
- [ ] **Interactive Algorithm Cards:** Rich cards showing algorithm descriptions, complexity ratings, and expected outcomes
- [ ] **Configuration Wizards:** Step-by-step configuration for each algorithm with intelligent defaults
- [ ] **Preview Mode:** Preview of expected algorithm outcomes before full execution
- [ ] **User Preference Integration:** Algorithm recommendations based on learned user preferences and behavior patterns
- [ ] **Hybrid Algorithm Builder:** Interface for combining different algorithms for different file types or directories

### Migration Plan Visualization & Management
- [ ] **Interactive Migration Plan Viewer:** Tree-view and list-view of proposed file operations with filtering and search
- [ ] **Visual Impact Assessment:** Charts showing migration complexity, time estimates, and storage changes
- [ ] **Plan Modification Interface:** Drag-and-drop interface for modifying proposed file movements and organization
- [ ] **Safety Validation Dashboard:** Comprehensive display of safety checks, risk assessment, and validation warnings
- [ ] **Step-by-Step Plan Breakdown:** Detailed view of migration phases with dependencies and sequencing
- [ ] **Plan Comparison Tool:** Side-by-side comparison of multiple algorithm results with recommendation engine

### Migration Execution & Monitoring
- [ ] **Execution Dashboard:** Real-time monitoring of migration progress with detailed status information
- [ ] **Interactive Progress Tracking:** File-level progress with pause, resume, and cancel capabilities
- [ ] **Error Handling Interface:** Clear display of errors with suggested resolutions and retry options
- [ ] **Rollback Capabilities:** One-click rollback interface with impact assessment and safety validation
- [ ] **Performance Monitoring:** Real-time display of I/O rates, completion estimates, and system impact
- [ ] **Success Metrics Dashboard:** Post-migration analysis showing organization improvement and efficiency gains

### User Learning & Preference Management
- [ ] **Preference Learning Center:** Interface showing learned preferences with confidence scores and modification options
- [ ] **Behavioral Pattern Viewer:** Timeline of user decisions and detected patterns with learning insights
- [ ] **Preference Override Interface:** Manual preference specification with explanation of impact on algorithm decisions
- [ ] **Learning Feedback System:** Interface for users to provide feedback on algorithm decisions and outcomes
- [ ] **Confidence Building Tools:** Progressive disclosure of system reasoning to build user trust over time
- [ ] **Preference Export/Import:** Backup and restore user preferences and learned patterns

### Integration with Core MediaMogul Features
- [ ] **File Browser Integration:** SmartMover actions directly accessible from file browser context menus
- [ ] **Task Queue Integration:** SmartMover operations visible in main task queue with appropriate priority and status
- [ ] **Notification System:** Smart notifications for analysis completion, migration status, and recommended actions
- [ ] **Search Integration:** SmartMover results and insights searchable through main MediaMogul search
- [ ] **Dashboard Widget Integration:** SmartMover summary widgets in main MediaMogul dashboard
- [ ] **Settings Integration:** SmartMover preferences integrated into main MediaMogul settings system

### Mobile & Responsive Design
- [ ] **Mobile-Optimized Interface:** Responsive design optimized for tablet and mobile access to SmartMover features
- [ ] **Progressive Web App Support:** Offline capabilities for viewing analysis results and migration status
- [ ] **Touch-Optimized Controls:** Mobile-friendly interaction patterns for plan modification and execution control
- [ ] **Simplified Mobile Workflows:** Streamlined mobile interfaces focusing on monitoring and basic control operations
- [ ] **Cross-Device Synchronization:** Seamless experience across desktop, tablet, and mobile devices
- [ ] **Mobile Notifications:** Push notifications for migration completion and critical status updates

## Technical Implementation

### Frontend Architecture

**SmartMover Main Component** (`components/smartmover/SmartMoverHub.tsx`)
```typescript
interface SmartMoverHubProps {
  analysisEngine: AnalysisEngineClient;
  algorithmEngine: AlgorithmEngineClient;
  migrationEngine: MigrationEngineClient;
  userPreferences: UserPreferencesClient;
}

interface SmartMoverState {
  activeTab: SmartMoverTab;
  currentAnalysis: ComprehensiveAnalysis | null;
  availablePlans: MigrationPlan[];
  activeMigration: MigrationExecution | null;
  userPreferences: UserPreferences;
  systemStatus: SystemStatus;
}

export const SmartMoverHub: React.FC<SmartMoverHubProps> = ({
  analysisEngine,
  algorithmEngine,
  migrationEngine,
  userPreferences
}) => {
  const [state, setState] = useState<SmartMoverState>(initialState);
  const [loading, setLoading] = useState<LoadingState>({});

  // Core SmartMover operations
  const triggerAnalysis = useCallback(async (analysisType: AnalysisType) => {
    setLoading(prev => ({ ...prev, analysis: true }));
    try {
      const analysis = await analysisEngine.performAnalysis(analysisType);
      setState(prev => ({ ...prev, currentAnalysis: analysis }));
      showNotification('Analysis completed successfully', 'success');
    } catch (error) {
      showNotification(`Analysis failed: ${error.message}`, 'error');
    } finally {
      setLoading(prev => ({ ...prev, analysis: false }));
    }
  }, [analysisEngine]);

  const executeAlgorithms = useCallback(async (selectedAlgorithms: string[]) => {
    if (!state.currentAnalysis) {
      showNotification('Please complete analysis first', 'warning');
      return;
    }

    setLoading(prev => ({ ...prev, algorithms: true }));
    try {
      const plans = await algorithmEngine.executeMultiple(
        selectedAlgorithms,
        state.currentAnalysis
      );
      setState(prev => ({ ...prev, availablePlans: Object.values(plans) }));
      showNotification(`Generated ${Object.keys(plans).length} migration plans`, 'success');
    } catch (error) {
      showNotification(`Algorithm execution failed: ${error.message}`, 'error');
    } finally {
      setLoading(prev => ({ ...prev, algorithms: false }));
    }
  }, [algorithmEngine, state.currentAnalysis]);

  return (
    <div className="smartmover-hub">
      <SmartMoverHeader 
        status={state.systemStatus}
        onRefresh={refreshSystemStatus}
      />
      
      <SmartMoverTabs
        activeTab={state.activeTab}
        onTabChange={setActiveTab}
        tabStates={getTabStates(state, loading)}
      />

      <div className="smartmover-content">
        {state.activeTab === 'dashboard' && (
          <SmartMoverDashboard
            analysis={state.currentAnalysis}
            plans={state.availablePlans}
            migration={state.activeMigration}
            onTriggerAnalysis={triggerAnalysis}
            onExecuteAlgorithms={executeAlgorithms}
          />
        )}

        {state.activeTab === 'analysis' && (
          <AnalysisVisualization
            analysis={state.currentAnalysis}
            onTriggerAnalysis={triggerAnalysis}
            loading={loading.analysis}
          />
        )}

        {state.activeTab === 'algorithms' && (
          <AlgorithmSelection
            availableAlgorithms={AVAILABLE_ALGORITHMS}
            userPreferences={state.userPreferences}
            onExecuteAlgorithms={executeAlgorithms}
            loading={loading.algorithms}
          />
        )}

        {state.activeTab === 'plans' && (
          <MigrationPlanManager
            plans={state.availablePlans}
            onExecutePlan={executeMigrationPlan}
            onModifyPlan={modifyMigrationPlan}
            onComparePlans={compareMigrationPlans}
          />
        )}

        {state.activeTab === 'execution' && (
          <MigrationExecutionMonitor
            activeMigration={state.activeMigration}
            onPause={pauseMigration}
            onResume={resumeMigration}
            onCancel={cancelMigration}
            onRollback={rollbackMigration}
          />
        )}

        {state.activeTab === 'preferences' && (
          <UserPreferenceManager
            preferences={state.userPreferences}
            learnedPatterns={state.learnedPatterns}
            onUpdatePreferences={updateUserPreferences}
            onProvideFeeback={provideLearningFeedback}
          />
        )}
      </div>
    </div>
  );
};
```

### Analysis Visualization Components

**Analysis Dashboard** (`components/smartmover/analysis/AnalysisDashboard.tsx`)
```typescript
interface AnalysisDashboardProps {
  analysis: ComprehensiveAnalysis | null;
  onTriggerAnalysis: (type: AnalysisType) => Promise<void>;
  loading: boolean;
}

export const AnalysisDashboard: React.FC<AnalysisDashboardProps> = ({
  analysis,
  onTriggerAnalysis,
  loading
}) => {
  const [selectedTab, setSelectedTab] = useState<AnalysisTab>('overview');
  
  if (!analysis) {
    return (
      <AnalysisEmptyState 
        onTriggerAnalysis={onTriggerAnalysis}
        loading={loading}
      />
    );
  }

  return (
    <div className="analysis-dashboard">
      <AnalysisHeader
        metadata={analysis.analysis_metadata}
        onRefresh={() => onTriggerAnalysis('incremental')}
        loading={loading}
      />

      <AnalysisTabNavigation
        selectedTab={selectedTab}
        onTabChange={setSelectedTab}
        analysis={analysis}
      />

      <div className="analysis-content">
        {selectedTab === 'overview' && (
          <AnalysisOverview analysis={analysis} />
        )}

        {selectedTab === 'library' && (
          <LibraryIntelligenceViewer 
            intelligence={analysis.library_analysis}
          />
        )}

        {selectedTab === 'external' && (
          <ExternalIntelligenceViewer 
            intelligence={analysis.external_service_data}
          />
        )}

        {selectedTab === 'user' && (
          <UserIntelligenceViewer 
            intelligence={analysis.user_behavior_patterns}
          />
        )}

        {selectedTab === 'system' && (
          <SystemIntelligenceViewer 
            intelligence={analysis.system_performance}
          />
        )}
      </div>
    </div>
  );
};
```

**Library Intelligence Viewer** (`components/smartmover/analysis/LibraryIntelligenceViewer.tsx`)
```typescript
export const LibraryIntelligenceViewer: React.FC<{
  intelligence: LibraryIntelligence;
}> = ({ intelligence }) => {
  return (
    <div className="library-intelligence-viewer">
      <div className="intelligence-grid">
        <ContentDistributionChart 
          distribution={intelligence.content_distribution}
        />
        
        <OrganizationPatternsCard 
          patterns={intelligence.organization_patterns}
        />
        
        <QualityAnalysisChart 
          quality={intelligence.quality_analysis}
        />
        
        <SizeDistributionChart 
          sizes={intelligence.size_distribution}
        />
      </div>

      <DuplicateAnalysisSection 
        duplicates={intelligence.duplicate_analysis}
        onViewDuplicates={handleViewDuplicates}
        onResolveDuplicates={handleResolveDuplicates}
      />

      <OptimizationOpportunitiesPanel 
        opportunities={intelligence.optimization_opportunities}
        onSelectOpportunity={handleSelectOpportunity}
      />
    </div>
  );
};
```

### Algorithm Selection & Configuration

**Algorithm Selection Component** (`components/smartmover/algorithms/AlgorithmSelection.tsx`)
```typescript
interface AlgorithmSelectionProps {
  availableAlgorithms: Algorithm[];
  userPreferences: UserPreferences;
  onExecuteAlgorithms: (algorithms: string[]) => Promise<void>;
  loading: boolean;
}

export const AlgorithmSelection: React.FC<AlgorithmSelectionProps> = ({
  availableAlgorithms,
  userPreferences,
  onExecuteAlgorithms,
  loading
}) => {
  const [selectedAlgorithms, setSelectedAlgorithms] = useState<string[]>([]);
  const [configuredAlgorithms, setConfiguredAlgorithms] = useState<Map<string, AlgorithmConfig>>(new Map());

  const recommendedAlgorithm = useMemo(() => {
    return recommendAlgorithmBasedOnPreferences(availableAlgorithms, userPreferences);
  }, [availableAlgorithms, userPreferences]);

  return (
    <div className="algorithm-selection">
      <AlgorithmRecommendationCard 
        recommended={recommendedAlgorithm}
        onSelect={(algorithm) => setSelectedAlgorithms([algorithm.name])}
      />

      <div className="algorithm-comparison-grid">
        {availableAlgorithms.map(algorithm => (
          <AlgorithmCard
            key={algorithm.name}
            algorithm={algorithm}
            selected={selectedAlgorithms.includes(algorithm.name)}
            configured={configuredAlgorithms.has(algorithm.name)}
            userPreferences={userPreferences}
            onSelect={handleAlgorithmSelect}
            onConfigure={handleAlgorithmConfigure}
            onPreview={handleAlgorithmPreview}
          />
        ))}
      </div>

      <AlgorithmExecutionPanel
        selectedAlgorithms={selectedAlgorithms}
        configuredAlgorithms={configuredAlgorithms}
        onExecute={() => onExecuteAlgorithms(selectedAlgorithms)}
        loading={loading}
      />

      <HybridAlgorithmBuilder
        availableAlgorithms={availableAlgorithms}
        onCreateHybrid={handleCreateHybridAlgorithm}
      />
    </div>
  );
};
```

**Algorithm Card Component** (`components/smartmover/algorithms/AlgorithmCard.tsx`)
```typescript
interface AlgorithmCardProps {
  algorithm: Algorithm;
  selected: boolean;
  configured: boolean;
  userPreferences: UserPreferences;
  onSelect: (algorithm: Algorithm) => void;
  onConfigure: (algorithm: Algorithm) => void;
  onPreview: (algorithm: Algorithm) => void;
}

export const AlgorithmCard: React.FC<AlgorithmCardProps> = ({
  algorithm,
  selected,
  configured,
  userPreferences,
  onSelect,
  onConfigure,
  onPreview
}) => {
  const suitabilityScore = calculateAlgorithmSuitability(algorithm, userPreferences);
  
  return (
    <Card className={`algorithm-card ${selected ? 'selected' : ''}`}>
      <CardHeader>
        <div className="algorithm-header">
          <h3>{algorithm.name}</h3>
          <ComplexityBadge rating={algorithm.complexity_rating} />
        </div>
        <SuitabilityScore score={suitabilityScore} />
      </CardHeader>

      <CardContent>
        <p className="algorithm-description">{algorithm.description}</p>
        
        <div className="algorithm-metrics">
          <MetricItem
            label="Organization Improvement"
            value={algorithm.expected_outcomes.organization_improvement}
            format="percentage"
          />
          <MetricItem
            label="Migration Complexity"
            value={algorithm.expected_outcomes.migration_complexity}
            format="complexity"
          />
          <MetricItem
            label="Estimated Duration"
            value={algorithm.expected_outcomes.estimated_duration}
            format="duration"
          />
        </div>

        <div className="algorithm-features">
          {algorithm.key_features.map(feature => (
            <FeatureBadge key={feature} feature={feature} />
          ))}
        </div>

        <PreferenceMatchIndicator
          algorithm={algorithm}
          preferences={userPreferences}
        />
      </CardContent>

      <CardActions>
        <Button
          variant={selected ? "default" : "outline"}
          onClick={() => onSelect(algorithm)}
        >
          {selected ? 'Selected' : 'Select'}
        </Button>
        
        <Button
          variant="outline"
          onClick={() => onConfigure(algorithm)}
        >
          Configure
        </Button>
        
        <Button
          variant="ghost"
          onClick={() => onPreview(algorithm)}
        >
          Preview
        </Button>
      </CardActions>
    </Card>
  );
};
```

### Migration Plan Management

**Migration Plan Manager** (`components/smartmover/plans/MigrationPlanManager.tsx`)
```typescript
interface MigrationPlanManagerProps {
  plans: MigrationPlan[];
  onExecutePlan: (planId: string) => Promise<void>;
  onModifyPlan: (planId: string, modifications: PlanModification[]) => Promise<void>;
  onComparePlans: (planIds: string[]) => void;
}

export const MigrationPlanManager: React.FC<MigrationPlanManagerProps> = ({
  plans,
  onExecutePlan,
  onModifyPlan,
  onComparePlans
}) => {
  const [selectedPlan, setSelectedPlan] = useState<string | null>(null);
  const [viewMode, setViewMode] = useState<PlanViewMode>('list');
  const [comparisonMode, setComparisonMode] = useState(false);
  const [selectedForComparison, setSelectedForComparison] = useState<string[]>([]);

  if (plans.length === 0) {
    return (
      <MigrationPlanEmptyState 
        onGeneratePlans={() => {/* Navigate to algorithm selection */}}
      />
    );
  }

  return (
    <div className="migration-plan-manager">
      <MigrationPlanHeader
        planCount={plans.length}
        viewMode={viewMode}
        onViewModeChange={setViewMode}
        comparisonMode={comparisonMode}
        onToggleComparison={() => setComparisonMode(!comparisonMode)}
      />

      {comparisonMode ? (
        <PlanComparisonInterface
          plans={plans}
          selectedForComparison={selectedForComparison}
          onSelectionChange={setSelectedForComparison}
          onCompare={() => onComparePlans(selectedForComparison)}
        />
      ) : (
        <div className="plan-management-layout">
          <PlanListView
            plans={plans}
            selectedPlan={selectedPlan}
            onSelectPlan={setSelectedPlan}
            viewMode={viewMode}
          />

          {selectedPlan && (
            <PlanDetailView
              plan={plans.find(p => p.plan_id === selectedPlan)!}
              onExecute={() => onExecutePlan(selectedPlan)}
              onModify={(modifications) => onModifyPlan(selectedPlan, modifications)}
            />
          )}
        </div>
      )}
    </div>
  );
};
```

**Interactive Migration Plan Viewer** (`components/smartmover/plans/InteractivePlanViewer.tsx`)
```typescript
export const InteractivePlanViewer: React.FC<{
  plan: MigrationPlan;
  onModify: (modifications: PlanModification[]) => void;
}> = ({ plan, onModify }) => {
  const [expandedSteps, setExpandedSteps] = useState<Set<string>>(new Set());
  const [modifications, setModifications] = useState<PlanModification[]>([]);
  const [filterState, setFilterState] = useState<PlanFilterState>({});

  const filteredSteps = useMemo(() => {
    return filterMigrationSteps(plan.migration_steps, filterState);
  }, [plan.migration_steps, filterState]);

  return (
    <div className="interactive-plan-viewer">
      <PlanSummaryCard plan={plan} />
      
      <PlanFilterControls
        filterState={filterState}
        onFilterChange={setFilterState}
        stepCounts={getStepCounts(plan.migration_steps)}
      />

      <ValidationWarningsPanel
        validation={plan.safety_validation}
        impact={plan.impact_assessment}
      />

      <div className="migration-steps-container">
        <VirtualizedStepList
          steps={filteredSteps}
          expandedSteps={expandedSteps}
          modifications={modifications}
          onToggleStep={handleToggleStep}
          onModifyStep={handleStepModification}
          onBatchModify={handleBatchModification}
        />
      </div>

      <PlanModificationPanel
        modifications={modifications}
        onApplyModifications={() => onModify(modifications)}
        onClearModifications={() => setModifications([])}
        onUndoModification={handleUndoModification}
      />
    </div>
  );
};
```

### Migration Execution & Monitoring

**Migration Execution Monitor** (`components/smartmover/execution/MigrationExecutionMonitor.tsx`)
```typescript
interface MigrationExecutionMonitorProps {
  activeMigration: MigrationExecution | null;
  onPause: () => Promise<void>;
  onResume: () => Promise<void>;
  onCancel: () => Promise<void>;
  onRollback: () => Promise<void>;
}

export const MigrationExecutionMonitor: React.FC<MigrationExecutionMonitorProps> = ({
  activeMigration,
  onPause,
  onResume,
  onCancel,
  onRollback
}) => {
  const [detailLevel, setDetailLevel] = useState<DetailLevel>('summary');
  
  if (!activeMigration) {
    return (
      <MigrationExecutionEmptyState 
        onStartMigration={() => {/* Navigate to plan selection */}}
      />
    );
  }

  return (
    <div className="migration-execution-monitor">
      <MigrationStatusHeader
        execution={activeMigration}
        onPause={onPause}
        onResume={onResume}
        onCancel={onCancel}
        onRollback={onRollback}
      />

      <MigrationProgressVisualization
        execution={activeMigration}
        detailLevel={detailLevel}
        onDetailLevelChange={setDetailLevel}
      />

      <div className="execution-details-grid">
        <PerformanceMetricsPanel 
          metrics={activeMigration.performance_metrics}
        />
        
        <CurrentOperationPanel 
          currentStep={activeMigration.current_step}
          stepProgress={activeMigration.step_progress}
        />
        
        <ErrorHandlingPanel 
          errors={activeMigration.errors}
          onRetryError={handleRetryError}
          onSkipError={handleSkipError}
        />

        <EstimationPanel 
          estimates={activeMigration.completion_estimates}
          actualProgress={activeMigration.progress}
        />
      </div>

      {detailLevel === 'detailed' && (
        <DetailedStepViewer
          steps={activeMigration.executed_steps}
          currentStep={activeMigration.current_step}
          upcomingSteps={activeMigration.upcoming_steps}
        />
      )}

      <MigrationLogsPanel 
        logs={activeMigration.execution_logs}
        onExportLogs={handleExportLogs}
        onFilterLogs={handleFilterLogs}
      />
    </div>
  );
};
```

### User Preference & Learning Management

**User Preference Manager** (`components/smartmover/preferences/UserPreferenceManager.tsx`)
```typescript
export const UserPreferenceManager: React.FC<{
  preferences: UserPreferences;
  learnedPatterns: LearnedPattern[];
  onUpdatePreferences: (preferences: UserPreferences) => Promise<void>;
  onProvideFeedback: (feedback: LearningFeedback) => Promise<void>;
}> = ({
  preferences,
  learnedPatterns,
  onUpdatePreferences,
  onProvideFeedback
}) => {
  const [editMode, setEditMode] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState<PreferenceCategory>('organization');

  return (
    <div className="user-preference-manager">
      <PreferenceHeader
        editMode={editMode}
        onToggleEdit={() => setEditMode(!editMode)}
        onExportPreferences={handleExportPreferences}
        onImportPreferences={handleImportPreferences}
      />

      <div className="preference-layout">
        <PreferenceCategoryNavigation
          selectedCategory={selectedCategory}
          onCategoryChange={setSelectedCategory}
          categories={PREFERENCE_CATEGORIES}
        />

        <div className="preference-content">
          {selectedCategory === 'organization' && (
            <OrganizationPreferences
              preferences={preferences.organization}
              editMode={editMode}
              onUpdate={handleOrganizationUpdate}
            />
          )}

          {selectedCategory === 'quality' && (
            <QualityPreferences
              preferences={preferences.quality}
              editMode={editMode}
              onUpdate={handleQualityUpdate}
            />
          )}

          {selectedCategory === 'performance' && (
            <PerformancePreferences
              preferences={preferences.performance}
              editMode={editMode}
              onUpdate={handlePerformanceUpdate}
            />
          )}

          {selectedCategory === 'learned' && (
            <LearnedPatternViewer
              patterns={learnedPatterns}
              onProvideFeedback={onProvideFeedback}
              onModifyPattern={handleModifyPattern}
            />
          )}
        </div>
      </div>

      <LearningInsightsPanel
        recentLearning={getRecentLearningEvents(learnedPatterns)}
        confidenceMetrics={calculateConfidenceMetrics(preferences)}
        onViewDetailedInsights={handleViewDetailedInsights}
      />
    </div>
  );
};
```

## API Integration Layer

**SmartMover API Client** (`services/api/smartmover.ts`)
```typescript
export class SmartMoverAPIClient {
  constructor(private httpClient: HttpClient) {}

  // Analysis operations
  async triggerAnalysis(analysisType: AnalysisType): Promise<ComprehensiveAnalysis> {
    const response = await this.httpClient.post('/api/v1/smartmover/analyze', {
      analysis_type: analysisType,
      include_incremental: true
    });
    return response.data;
  }

  async getAnalysisStatus(): Promise<AnalysisStatus> {
    const response = await this.httpClient.get('/api/v1/smartmover/analysis/status');
    return response.data;
  }

  // Algorithm operations
  async executeAlgorithms(
    algorithms: string[],
    analysis: ComprehensiveAnalysis
  ): Promise<Record<string, MigrationPlan>> {
    const response = await this.httpClient.post('/api/v1/smartmover/algorithms/execute-all', {
      algorithms,
      analysis_id: analysis.analysis_metadata.analysis_id
    });
    return response.data;
  }

  async comparePlans(planIds: string[]): Promise<PlanComparison> {
    const response = await this.httpClient.post('/api/v1/smartmover/plans/compare', {
      plan_ids: planIds
    });
    return response.data;
  }

  // Migration execution
  async executeMigrationPlan(planId: string): Promise<MigrationExecution> {
    const response = await this.httpClient.post(`/api/v1/smartmover/plans/${planId}/execute`);
    return response.data;
  }

  async getMigrationProgress(executionId: string): Promise<MigrationProgress> {
    const response = await this.httpClient.get(`/api/v1/smartmover/execution/${executionId}/progress`);
    return response.data;
  }

  // User preferences
  async getUserPreferences(): Promise<UserPreferences> {
    const response = await this.httpClient.get('/api/v1/smartmover/preferences');
    return response.data;
  }

  async updateUserPreferences(preferences: UserPreferences): Promise<void> {
    await this.httpClient.put('/api/v1/smartmover/preferences', preferences);
  }

  async provideLearningFeedback(feedback: LearningFeedback): Promise<void> {
    await this.httpClient.post('/api/v1/smartmover/preferences/learn', feedback);
  }
}
```

## Mobile & Responsive Design

**Responsive SmartMover Layout** (`components/smartmover/mobile/ResponsiveSmartMover.tsx`)
```typescript
export const ResponsiveSmartMover: React.FC<SmartMoverHubProps> = (props) => {
  const { isMobile, isTablet } = useResponsiveDesign();
  
  if (isMobile) {
    return <MobileSmartMoverInterface {...props} />;
  }
  
  if (isTablet) {
    return <TabletSmartMoverInterface {...props} />;
  }
  
  return <DesktopSmartMoverInterface {...props} />;
};

const MobileSmartMoverInterface: React.FC<SmartMoverHubProps> = (props) => {
  return (
    <div className="mobile-smartmover">
      <MobileNavigationTabs />
      <SwipeableViews>
        <MobileStatusOverview />
        <MobileExecutionMonitor />
        <MobileSettingsPanel />
      </SwipeableViews>
      <MobileActionButton />
    </div>
  );
};
```

## Database Schema Extensions

**UI State & Session Management** (`migrations/016_smartmover_ui.sql`)
```sql
CREATE TABLE smartmover_ui_sessions (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    session_type TEXT NOT NULL,        -- analysis, algorithm_selection, plan_management, execution
    session_data TEXT NOT NULL,       -- JSON session state
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    expires_at INTEGER,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_ui_sessions_user_id ON smartmover_ui_sessions(user_id);
CREATE INDEX idx_ui_sessions_type ON smartmover_ui_sessions(session_type);
CREATE INDEX idx_ui_sessions_expires_at ON smartmover_ui_sessions(expires_at);

CREATE TABLE smartmover_user_feedback (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    feedback_type TEXT NOT NULL,      -- algorithm_rating, plan_modification, execution_outcome
    target_id TEXT NOT NULL,          -- ID of algorithm, plan, or execution
    feedback_data TEXT NOT NULL,      -- JSON feedback details
    sentiment_score REAL,             -- -1.0 to 1.0
    created_at INTEGER NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_user_feedback_user_id ON smartmover_user_feedback(user_id);
CREATE INDEX idx_user_feedback_type ON smartmover_user_feedback(feedback_type);
CREATE INDEX idx_user_feedback_target_id ON smartmover_user_feedback(target_id);
```

## Integration Points

### Main MediaMogul Integration
- **Dashboard Widgets:** SmartMover summary cards in main dashboard
- **File Browser Context:** SmartMover actions in file/folder context menus
- **Task Queue Integration:** SmartMover operations visible in main task manager
- **Notification System:** SmartMover alerts through main notification system
- **Search Integration:** SmartMover results searchable through global search

### External Service Integration
- **Sonarr/Radarr Configuration:** Direct links to external service settings
- **Path Mapping Assistance:** Visual path mapping tools integrated with external services
- **Quality Profile Sync:** Automatic sync of quality preferences with external services
- **Service Health Monitoring:** Integration with external service health checks

## Validation & Testing

### User Experience Testing
- [ ] Usability testing across different user experience levels
- [ ] Mobile and tablet interface validation
- [ ] Accessibility compliance testing (WCAG 2.1 AA)
- [ ] Cross-browser compatibility testing
- [ ] Performance testing on various device types

### Integration Testing
- [ ] End-to-end workflow testing (analysis → algorithm → plan → execution)
- [ ] Cross-component state management validation
- [ ] Real-time update synchronization testing
- [ ] External service integration validation
- [ ] Error handling and recovery testing

### Performance Testing
- [ ] Large library interface responsiveness (100k+ files)
- [ ] Real-time update performance during long operations
- [ ] Memory usage optimization for complex visualizations
- [ ] Network efficiency for frequent API calls
- [ ] Mobile performance optimization

### User Acceptance Testing
- [ ] User workflow completion rates
- [ ] Interface learning curve assessment
- [ ] User satisfaction with transparency and control
- [ ] Effectiveness of preference learning interface
- [ ] Overall system trust and confidence building

## Dependencies

**Required Stories:**
- Story 5.1: SmartMover Analysis Engine Foundation (analysis data and intelligence)
- Story 5.2: Migration Strategy Algorithms (algorithms and migration plans)
- Epic 4: External Services Integration (external service data integration)
- Epic 2: Task Engine (background operation integration)

**Technical Dependencies:**
- React 18+ with advanced hooks and concurrent features
- Advanced data visualization libraries (D3.js, Chart.js, or similar)
- Real-time update framework (WebSockets or Server-Sent Events)
- Mobile-optimized UI component library
- State management solution for complex application state

## Definition of Done

- [ ] Complete SmartMover user interface with all major workflows implemented
- [ ] Analysis results visualization with interactive charts and data exploration
- [ ] Algorithm selection interface with comprehensive comparison and configuration
- [ ] Migration plan management with modification capabilities and safety validation
- [ ] Real-time migration execution monitoring with control capabilities
- [ ] User preference management with learning feedback integration
- [ ] Mobile and tablet responsive design with optimized workflows
- [ ] Integration with core MediaMogul features and external services
- [ ] Complete API integration layer with error handling and offline support
- [ ] Comprehensive testing across all user interface components and workflows

## Success Metrics

- **User Adoption:** 80%+ of users successfully complete full SmartMover workflow within first month
- **Interface Efficiency:** 90%+ reduction in time to generate and execute migration plans compared to manual process
- **User Satisfaction:** 90%+ positive user feedback on interface usability and transparency
- **Learning Effectiveness:** Measurable improvement in algorithm recommendation accuracy over time
- **Mobile Experience:** 85%+ user satisfaction with mobile and tablet interfaces
- **Error Recovery:** 99%+ successful error recovery rate with clear user guidance

## Epic 5 Completion

With Story 5.3 completed, Epic 5: SmartMover Automated Migration Planning will be fully implemented, providing:

1. **Comprehensive Analysis Engine** (Story 5.1) - Multi-source intelligence gathering
2. **Four Migration Algorithms** (Story 5.2) - Diverse automation strategies with AI/ML integration
3. **Complete User Interface** (Story 5.3) - Intuitive, transparent, and powerful user experience

## PRD Requirements Fulfilled

- **Automated Migration Planning:** Complete system for intelligent file organization automation
- **User Choice and Control:** Multiple algorithms with full user control and transparency
- **External Service Integration:** Seamless integration with Sonarr/Radarr for enhanced intelligence
- **Learning and Adaptation:** AI-driven system that improves over time with user feedback
- **Safety and Reliability:** Comprehensive validation, safety checks, and rollback capabilities
- **Scalable Performance:** Support for large libraries with efficient processing and responsive UI

## Future Enhancements

This comprehensive SmartMover system provides the foundation for future enhancements:
- **Advanced AI/ML Integration:** Enhanced machine learning capabilities for even smarter automation
- **Cloud Integration:** Cloud storage optimization and hybrid migration strategies
- **Advanced Analytics:** Detailed analytics and reporting on library optimization outcomes
- **Team Collaboration:** Multi-user planning and approval workflows for shared libraries


## File List

*To be populated during implementation*

## Dev Agent Record

### Implementation Notes
*To be populated during development*

### Completion Notes
*To be populated upon completion*

### Debug Log References
*To be populated if debugging required*

## QA Results

*To be populated during QA review*
