# Story 2.3: MediaInfo Data Background Processing

## Story: MediaInfo Metadata Extraction Service

## Story
As a user,
I want MediaMogul to extract and store detailed media metadata from my video and audio files as a background task,
So that I can view comprehensive technical information about my media files and make informed decisions about encoding, quality, and organization.

## Story Context

**Epic:** 2 - Asynchronous Task Engine & Data Enrichment  
**Dependencies:** Story 2.1 (Task Engine Foundation), Story 1.3 (File System Scanning)  
**Story Type:** Data Enrichment - Background Processing  

This story implements media metadata extraction using the `mediainfo` command-line tool as a background task. It fulfills FR6 from the PRD: "The system shall use the MediaInfo library to extract and store specified metadata from media files as a background task."

## Acceptance Criteria

### MediaInfo Task Creation & Scheduling
- [ ] Users can trigger MediaInfo extraction for individual media files via file browser context menu
- [ ] Users can trigger bulk MediaInfo extraction for entire folders/disks via dashboard
- [ ] System creates `scan_mediainfo` tasks with appropriate execution priority
- [ ] Tasks include file selection criteria and media type filtering in payload
- [ ] Smart scheduling avoids creating duplicate tasks for same files
- [ ] Only processes media files (video, audio) based on file extension filtering

### MediaInfo Extraction Logic
- [ ] **Skip existing metadata:** Only extract MediaInfo if `files.mediainfo_data` field is NULL
- [ ] **Skip modified files:** Only extract MediaInfo if file has NOT been modified since last extraction
- [ ] **File type validation:** Only process known media file extensions (.mp4, .mkv, .avi, .mov, .mp3, .flac, etc.)
- [ ] **mediainfo command execution:** Execute system `mediainfo` binary with JSON output format
- [ ] **Progress tracking:** Update `files_processed` and `bytes_processed` during execution
- [ ] **Atomic updates:** MediaInfo data and timestamp updated together in single transaction

### MediaInfo Command Integration
- [ ] **System dependency check:** Verify `mediainfo` binary is available during task execution
- [ ] **JSON output format:** Execute `mediainfo --Output=JSON filename` for structured data
- [ ] **Error handling:** Handle command failures, missing files, corrupted media gracefully
- [ ] **Timeout handling:** Set reasonable timeouts for mediainfo execution (30 seconds default)
- [ ] **Resource limiting:** Configurable process limiting to prevent system overload

### File Model Integration
- [ ] Store MediaInfo JSON in `files.mediainfo_data` field as TEXT blob
- [ ] Update `files.mediainfo_extracted_on` timestamp when extraction completes
- [ ] Update `files.content_type` based on MediaInfo analysis (video/mp4, audio/flac, etc.)
- [ ] Create file history record with action `mediainfo_extracted`
- [ ] Handle file-not-found scenarios (mark as deleted, don't fail task)
- [ ] Validate JSON structure before database storage

### Media Information Parsing
- [ ] **Video metadata:** Resolution, codec, bitrate, duration, frame rate, aspect ratio
- [ ] **Audio metadata:** Codec, bitrate, sample rate, channels, duration, language
- [ ] **Container metadata:** Format, file size, creation date, encoder information
- [ ] **Stream analysis:** Multiple video/audio tracks with individual properties
- [ ] **Quality assessment:** Basic quality metrics (bitrate vs resolution analysis)

### User Interface Integration
- [ ] File browser displays media type icons and basic info (resolution, duration)
- [ ] Media details panel shows comprehensive MediaInfo data in organized sections
- [ ] Progress indicator shows MediaInfo extraction progress for running tasks
- [ ] Bulk actions UI allows starting MediaInfo extraction on selected files/folders
- [ ] Task queue UI shows MediaInfo tasks with file count and progress
- [ ] Media file filtering options in file browser (by codec, resolution, etc.)

## Technical Implementation

### Go Backend Components

**MediaInfo Task Executor** (`internal/service/taskengine/executors/mediainfo.go`)
```go
type MediaInfoTaskExecutor struct {
    fileRepo     repository.FileRepository
    historyRepo  repository.FileHistoryRepository
    logger       zerolog.Logger
    config       MediaInfoConfig
}

type MediaInfoTaskPayload struct {
    FileUIDs       []string `json:"file_uids,omitempty"`       // Specific files
    FolderPaths    []string `json:"folder_paths,omitempty"`    // Entire folders
    DiskGUID       string   `json:"disk_guid,omitempty"`       // Entire disk
    ForceReextract bool     `json:"force_reextract"`           // Override existing data
    MediaTypes     []string `json:"media_types,omitempty"`     // Filter: video, audio, image
}

func (e *MediaInfoTaskExecutor) Execute(ctx context.Context, task *Task) error
func (e *MediaInfoTaskExecutor) extractMediaInfo(filepath string) (*MediaInfoData, error)
func (e *MediaInfoTaskExecutor) parseMediaInfoJSON(jsonData []byte) (*MediaInfoData, error)
func (e *MediaInfoTaskExecutor) updateFileWithMediaInfo(fileUID string, data *MediaInfoData) error
func (e *MediaInfoTaskExecutor) isMediaFile(filename string) bool
```

**MediaInfo Data Structure** (`internal/model/mediainfo.go`)
```go
type MediaInfoData struct {
    General GeneralTrack `json:"General,omitempty"`
    Video   []VideoTrack `json:"Video,omitempty"`
    Audio   []AudioTrack `json:"Audio,omitempty"`
    Text    []TextTrack  `json:"Text,omitempty"`
}

type GeneralTrack struct {
    Format           string `json:"Format"`
    FileSize         int64  `json:"FileSize"`
    Duration         int64  `json:"Duration"`
    OverallBitRate   int    `json:"OverallBitRate"`
    EncodedDate      string `json:"Encoded_Date"`
    WritingApplication string `json:"Writing_Application"`
}

type VideoTrack struct {
    Format         string `json:"Format"`
    CodecID        string `json:"CodecID"`
    Width          int    `json:"Width"`
    Height         int    `json:"Height"`
    AspectRatio    string `json:"DisplayAspectRatio"`
    FrameRate      string `json:"FrameRate"`
    BitRate        int    `json:"BitRate"`
    Duration       int64  `json:"Duration"`
    ColorSpace     string `json:"ColorSpace"`
    ChromaSubsampling string `json:"ChromaSubsampling"`
}

type AudioTrack struct {
    Format         string `json:"Format"`
    CodecID        string `json:"CodecID"`
    SamplingRate   int    `json:"SamplingRate"`
    Channels       int    `json:"Channels"`
    BitRate        int    `json:"BitRate"`
    Duration       int64  `json:"Duration"`
    Language       string `json:"Language"`
    Title          string `json:"Title"`
}
```

**MediaInfo Service** (`internal/service/mediainfo/service.go`)
```go
type Service interface {
    CreateMediaInfoTask(payload MediaInfoTaskPayload, priority ExecutionPriority) (*Task, error)
    GetMediaInfoStatistics(diskGUID string) (*MediaInfoStats, error)
    GetMediaFilesByCodec(codec string) ([]*File, error)
    GetMediaFilesByQuality(minWidth, maxWidth int) ([]*File, error)
    GetMediaInfoProgress() ([]*TaskProgress, error)
}

type MediaInfoStats struct {
    TotalMediaFiles      int     `json:"total_media_files"`
    FilesWithMediaInfo   int     `json:"files_with_mediainfo"`
    MediaInfoCoverage    float64 `json:"mediainfo_coverage"`
    VideoFiles           int     `json:"video_files"`
    AudioFiles           int     `json:"audio_files"`
    TopVideoCodecs       []CodecStat `json:"top_video_codecs"`
    TopAudioCodecs       []CodecStat `json:"top_audio_codecs"`
    QualityDistribution  []QualityStat `json:"quality_distribution"`
}
```

### Command Execution & System Integration
- **Binary verification:** Check `mediainfo --version` during service startup
- **Command template:** `mediainfo --Output=JSON --LogFile=/tmp/mediainfo.log "{filepath}"`
- **Process management:** Use Go's `exec.CommandContext` with timeout
- **Error categorization:** Distinguish between system errors, file errors, parsing errors
- **Resource limiting:** Maximum concurrent mediainfo processes (default: 2)

### API Endpoints
- `POST /api/v1/mediainfo/extract` - Create MediaInfo extraction task
- `GET /api/v1/mediainfo/stats` - Get MediaInfo coverage statistics
- `GET /api/v1/mediainfo/stats/{disk_guid}` - Get disk-specific MediaInfo stats
- `GET /api/v1/mediainfo/codecs` - List all detected codecs with usage counts
- `GET /api/v1/mediainfo/quality` - Get quality distribution (resolution, bitrate ranges)
- `GET /api/v1/files/{uid}/mediainfo` - Get parsed MediaInfo for specific file
- `DELETE /api/v1/mediainfo/{file_uid}` - Clear MediaInfo data for file

### Frontend Components

**MediaInfo Actions Component** (`components/mediainfo/MediaInfoActions.tsx`)
- Context menu items for media files ("Extract Media Info")
- Bulk action buttons for folders/disks ("Extract Media Info for All")
- Progress indicators during extraction
- Media type filtering options

**Media Details Panel** (`components/files/MediaDetailsPanel.tsx`)
- Organized display of video/audio/container information
- Technical specifications in user-friendly format
- Codec information with descriptions
- Quality assessment indicators

**Media Statistics Dashboard** (`components/dashboard/MediaStats.tsx`)
- MediaInfo coverage percentage per disk
- Codec distribution charts
- Quality distribution graphs
- Recent MediaInfo extraction activity

**Media File Browser Enhancements** (`components/files/MediaFileBrowser.tsx`)
- Media type icons (video/audio) with resolution/duration overlay
- Codec badges and quality indicators
- Filtering by media type, codec, resolution, bitrate
- Sorting by technical properties

### Configuration Options
```env
# MediaInfo Processing Configuration
MEDIAINFO_BINARY_PATH=/usr/bin/mediainfo     # Path to mediainfo binary
MEDIAINFO_TIMEOUT_SECONDS=30                 # Timeout per file
MEDIAINFO_CONCURRENT_PROCESSES=2             # Max concurrent extractions
MEDIAINFO_BATCH_SIZE=50                      # Files processed per task batch
MEDIAINFO_SUPPORTED_EXTENSIONS=mp4,mkv,avi,mov,wmv,flv,mp3,flac,wav,aac,ogg,m4a
MEDIAINFO_LOG_ENABLED=true                   # Enable detailed logging
MEDIAINFO_RETRY_ATTEMPTS=2                   # Retry failed extractions
```

## Validation & Testing

### Unit Tests
- [ ] MediaInfo command execution and JSON parsing
- [ ] File type detection and filtering logic
- [ ] Data structure validation and storage
- [ ] Error handling for various failure scenarios
- [ ] Progress tracking accuracy

### Integration Tests
- [ ] End-to-end MediaInfo task execution with real media files
- [ ] File browser MediaInfo display integration
- [ ] Bulk operation performance with mixed file types
- [ ] Task cancellation and recovery scenarios
- [ ] System dependency handling (missing mediainfo binary)

### Performance Tests
- [ ] Large media file processing (>10GB files)
- [ ] Bulk processing of many small media files
- [ ] Memory usage during JSON parsing and storage
- [ ] System resource impact during extraction
- [ ] Database performance with large MediaInfo JSON blobs

### Media File Compatibility
- [ ] Common video formats: MP4, MKV, AVI, MOV, WMV, FLV
- [ ] Common audio formats: MP3, FLAC, WAV, AAC, OGG, M4A
- [ ] Edge cases: corrupted files, encrypted files, unsupported formats
- [ ] International character handling in metadata
- [ ] Very long duration files (>24 hours)

## Dependencies

**Required Stories:**
- Story 2.1: Task Engine Foundation (task creation, execution, progress tracking)
- Story 1.3: File System Scanning (file discovery and metadata)

**System Dependencies:**
- `mediainfo` binary installed and accessible in PATH
- Sufficient disk space for temporary files and logs
- File system permissions to read media files

**Database Dependencies:**
- `files.mediainfo_data` field (already in V4 schema)
- `files.mediainfo_extracted_on` field (already in V4 schema)
- `files.content_type` field (already in V4 schema)
- `file_history` table for audit trail

## Definition of Done

- [ ] MediaInfo extraction tasks execute successfully for individual files and bulk operations
- [ ] System intelligently skips files that already have valid MediaInfo data
- [ ] Only processes recognized media file types based on extension
- [ ] MediaInfo command integration works reliably with timeout and error handling
- [ ] Extracted data stored as structured JSON in database
- [ ] File browser displays media information appropriately with type indicators
- [ ] Bulk actions UI allows starting MediaInfo extraction on folders/disks
- [ ] Progress tracking updates accurately during task execution
- [ ] File history maintains audit trail of MediaInfo extractions
- [ ] Error handling gracefully manages missing binary, corrupted files, timeouts
- [ ] Performance impact is minimal during background processing
- [ ] All API endpoints implemented and tested
- [ ] Media file filtering and display enhancements work correctly

## Success Metrics

- **Compatibility:** Successfully extract MediaInfo from 95%+ of common media files
- **Performance:** Process 100+ small media files per minute, limited by I/O for large files
- **Reliability:** <1% task failure rate due to application errors (excluding corrupted media)
- **Accuracy:** 100% JSON parsing success for valid mediainfo output
- **Resource Usage:** <200MB memory overhead during processing
- **User Experience:** Progress updates within 3 seconds, responsive UI during processing

## Next Stories

This story enables:
- **Story 2.4:** Task Queue Management UI (comprehensive task monitoring interface)
- **Story 2.5:** Opportunistic Task Execution Logic (smart disk power management)
- **Story 4.x:** Media Library Enhancement (advanced media organization features)

## PRD Requirements Fulfilled

- **FR6:** "The system shall use the MediaInfo library to extract and store specified metadata from media files as a background task."
- **Background Processing:** Implements as asynchronous task to avoid UI blocking
- **Technical Metadata:** Provides comprehensive technical information for media management
- **Smart Processing:** Avoids redundant extractions for unchanged files
