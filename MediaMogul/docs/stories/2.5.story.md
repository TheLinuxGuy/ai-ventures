# Story 2.5: Opportunistic Task Execution Logic

## Story: Data Verification and Quality Assurance

## Story
As a user,
I want MediaMogul to intelligently execute background tasks only when my disks are already active,
So that I can preserve disk lifespan, reduce power consumption, and avoid unnecessary disk spin-ups while still getting my background processing completed efficiently.

## Story Context

**Epic:** 2 - Asynchronous Task Engine & Data Enrichment  
**Dependencies:** Story 2.1 (Task Engine Foundation), Story 2.4 (Task Queue UI), Story 1.6 (Power-Efficient Framework)  
**Story Type:** System Intelligence - Power Management  

This story implements the sophisticated opportunistic task execution logic that respects disk power states and user preferences. It fulfills FR12 from the PRD: "A conditional monitoring process shall run only when 'opportunistic' tasks are queued. This monitor will trigger task execution once it detects that all required source and destination disks are active."

## Acceptance Criteria

### Disk Power State Monitoring
- [ ] **Real-time power monitoring:** Continuously monitor power status of all registered disks
- [ ] **Power state detection:** Detect active, spinning-down, sleeping, and unknown disk states
- [ ] **State change tracking:** Log disk power state transitions with timestamps
- [ ] **Monitoring efficiency:** Check disk power status every 30 seconds (configurable)
- [ ] **Resource optimization:** Only monitor when opportunistic tasks are queued

### Opportunistic Task Scheduling Logic
- [ ] **Disk readiness validation:** Execute opportunistic tasks only when ALL required disks are active
- [ ] **Task eligibility checking:** Verify task dependencies and prerequisites before execution
- [ ] **Priority override:** Immediate tasks execute regardless of disk power state
- [ ] **Scheduled task respect:** Scheduled tasks execute at their specified time regardless of power state
- [ ] **User confirmation:** Prompt user before waking sleeping disks for immediate tasks

### Smart Task Queue Management
- [ ] **Opportunistic queue separation:** Maintain separate queue for opportunistic tasks
- [ ] **Task promotion:** Promote opportunistic tasks to immediate when disks become active
- [ ] **Batch optimization:** Group related opportunistic tasks for efficient execution
- [ ] **Timeout handling:** Move long-pending opportunistic tasks to scheduled after configurable timeout
- [ ] **User override:** Allow users to force execution of opportunistic tasks

### Power State Integration
- [ ] **SMART data integration:** Use disk health monitoring data to detect power states
- [ ] **Command-line tools:** Execute `smartctl`, `hdparm`, or `/sys/block` checks for disk status
- [ ] **Cross-platform support:** Handle different power state detection methods per OS
- [ ] **Fallback mechanisms:** Graceful handling when power state cannot be determined
- [ ] **Cache power states:** Avoid excessive system calls with intelligent caching

### User Interface Enhancements
- [ ] **Power status indicators:** Display disk power states in dashboard and task queue
- [ ] **Opportunistic task badges:** Visual indicators for tasks waiting for disk activity
- [ ] **Power state timeline:** Historical view of disk power state changes
- [ ] **User preferences:** Settings for opportunistic behavior (aggressive, balanced, conservative)
- [ ] **Wake disk confirmations:** Modal dialogs asking permission to wake sleeping disks

### Configuration & Preferences
- [ ] **Power monitoring settings:** Enable/disable opportunistic execution, monitoring intervals
- [ ] **Disk wake policies:** User preference for automatic vs. manual disk wake
- [ ] **Task timeout configuration:** How long opportunistic tasks wait before promotion
- [ ] **Batch window settings:** Time window for grouping related opportunistic tasks
- [ ] **Power state override:** Admin setting to disable power management entirely

## Technical Implementation

### Go Backend Components

**Power Monitor Service** (`internal/service/power/monitor.go`)
```go
type PowerMonitor struct {
    diskRepo     repository.DiskRepository
    taskEngine   *taskengine.Engine
    config       PowerMonitorConfig
    logger       zerolog.Logger
    ticker       *time.Ticker
    stopChan     chan struct{}
    diskStates   map[string]DiskPowerState
    mu           sync.RWMutex
}

type DiskPowerState struct {
    GUID         string    `json:"guid"`
    PowerStatus  string    `json:"power_status"`  // active, standby, sleeping, unknown
    LastChecked  time.Time `json:"last_checked"`
    LastActive   time.Time `json:"last_active"`
    StateChanges int       `json:"state_changes"`
}

func (pm *PowerMonitor) Start() error
func (pm *PowerMonitor) Stop()
func (pm *PowerMonitor) GetDiskPowerState(guid string) (DiskPowerState, error)
func (pm *PowerMonitor) GetAllDiskStates() map[string]DiskPowerState
func (pm *PowerMonitor) checkDiskPowerStates() error
func (pm *PowerMonitor) detectPowerState(diskPath string) (string, error)
func (pm *PowerMonitor) processOpportunisticTasks() error
```

**Opportunistic Scheduler** (`internal/service/taskengine/opportunistic.go`)
```go
type OpportunisticScheduler struct {
    taskRepo     repository.TaskRepository
    powerMonitor *power.PowerMonitor
    config       OpportunisticConfig
    logger       zerolog.Logger
}

type OpportunisticConfig struct {
    MonitoringInterval    time.Duration `json:"monitoring_interval"`
    TaskTimeoutHours      int           `json:"task_timeout_hours"`
    BatchWindowMinutes    int           `json:"batch_window_minutes"`
    RequireAllDisksActive bool          `json:"require_all_disks_active"`
    AutoWakeDisks         bool          `json:"auto_wake_disks"`
}

func (os *OpportunisticScheduler) EvaluateOpportunisticTasks() error
func (os *OpportunisticScheduler) CanExecuteTask(task *Task) (bool, string)
func (os *OpportunisticScheduler) PromoteEligibleTasks() ([]string, error)
func (os *OpportunisticScheduler) GroupRelatedTasks(tasks []*Task) [][]*Task
func (os *OpportunisticScheduler) HandleExpiredTasks() error
```

**Disk Power Detection** (`internal/service/power/detector.go`)
```go
type PowerDetector interface {
    DetectPowerState(diskPath string) (PowerState, error)
    GetDetectionMethod() string
    IsAvailable() bool
}

type SmartctlDetector struct {
    logger zerolog.Logger
}

type SysBlockDetector struct {
    logger zerolog.Logger
}

type HdparmDetector struct {
    logger zerolog.Logger
}

func (d *SmartctlDetector) DetectPowerState(diskPath string) (PowerState, error) {
    // Execute: smartctl -n standby -H /dev/sdX
    // Parse output for power state
}

func (d *SysBlockDetector) DetectPowerState(diskPath string) (PowerState, error) {
    // Read: /sys/block/sdX/queue/scheduler
    // Check: /proc/diskstats for recent activity
}
```

**Task Engine Integration** (`internal/service/taskengine/scheduler.go`)
```go
func (s *Scheduler) evaluateTaskForExecution(task *Task) (bool, string) {
    switch task.ExecutionPriority {
    case PriorityImmediate:
        // Execute immediately, possibly waking disks
        return s.handleImmediateTask(task)
    case PriorityOpportunistic:
        // Check if required disks are active
        return s.handleOpportunisticTask(task)
    case PriorityScheduled:
        // Execute if scheduled time has arrived
        return s.handleScheduledTask(task)
    }
}

func (s *Scheduler) handleOpportunisticTask(task *Task) (bool, string) {
    requiredDisks := s.getRequiredDisks(task)
    for _, diskGUID := range requiredDisks {
        state, err := s.powerMonitor.GetDiskPowerState(diskGUID)
        if err != nil || state.PowerStatus != "active" {
            return false, fmt.Sprintf("Disk %s is not active (%s)", diskGUID, state.PowerStatus)
        }
    }
    return true, "All required disks are active"
}
```

### API Endpoints
- `GET /api/v1/power/disks` - Get power states of all disks
- `GET /api/v1/power/disks/{guid}` - Get power state of specific disk
- `GET /api/v1/power/history` - Get disk power state change history
- `POST /api/v1/power/wake/{guid}` - Wake specific disk (with user confirmation)
- `PUT /api/v1/power/settings` - Update power management settings
- `GET /api/v1/tasks/opportunistic` - Get opportunistic tasks waiting for disk activity
- `POST /api/v1/tasks/opportunistic/promote` - Promote opportunistic tasks to immediate

### Frontend Components

**Power Status Dashboard** (`components/power/PowerStatusDashboard.tsx`)
```tsx
interface DiskPowerState {
  guid: string
  label: string
  powerStatus: 'active' | 'standby' | 'sleeping' | 'unknown'
  lastChecked: number
  lastActive: number
  waitingTasks: number
}

export function PowerStatusDashboard() {
  const { diskStates, isLoading } = useDiskPowerStates()
  
  return (
    <div className="power-status-grid">
      {diskStates.map(disk => (
        <DiskPowerCard 
          key={disk.guid}
          disk={disk}
          onWake={handleWakeDisk}
        />
      ))}
    </div>
  )
}
```

**Opportunistic Task Queue** (`components/tasks/OpportunisticTaskQueue.tsx`)
```tsx
export function OpportunisticTaskQueue({ tasks }: OpportunisticTaskQueueProps) {
  const { promoteTask, wakeDisk } = useTaskActions()
  
  return (
    <div className="opportunistic-queue">
      <QueueHeader 
        count={tasks.length}
        onPromoteAll={handlePromoteAll}
      />
      {tasks.map(task => (
        <OpportunisticTaskCard
          key={task.uid}
          task={task}
          blockedBy={getBlockingDisks(task)}
          onPromote={() => promoteTask(task.uid)}
          onWakeDisks={() => wakeDiskForTask(task)}
        />
      ))}
    </div>
  )
}
```

**Disk Wake Confirmation Modal** (`components/power/WakeDiskModal.tsx`)
```tsx
export function WakeDiskModal({ disk, tasks, isOpen, onClose }: WakeDiskModalProps) {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Wake Disk: {disk.label}</DialogTitle>
          <DialogDescription>
            This will spin up the disk and may increase power consumption and wear.
          </DialogDescription>
        </DialogHeader>
        
        <div className="wake-disk-details">
          <div className="disk-info">
            <span>Current Status: {disk.powerStatus}</span>
            <span>Last Active: {formatTimeAgo(disk.lastActive)}</span>
          </div>
          
          <div className="waiting-tasks">
            <h4>Tasks waiting for this disk:</h4>
            {tasks.map(task => (
              <TaskSummary key={task.uid} task={task} />
            ))}
          </div>
        </div>
        
        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Cancel</Button>
          <Button onClick={() => handleWakeDisk(disk.guid)}>
            Wake Disk
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

**Power Settings Panel** (`components/settings/PowerSettings.tsx`)
```tsx
export function PowerSettings() {
  const { settings, updateSettings } = usePowerSettings()
  
  return (
    <SettingsSection title="Power Management">
      <SettingToggle
        label="Enable Opportunistic Execution"
        description="Only run background tasks when disks are already active"
        checked={settings.opportunisticEnabled}
        onChange={(enabled) => updateSettings({ opportunisticEnabled: enabled })}
      />
      
      <SettingSelect
        label="Disk Wake Policy"
        description="How to handle tasks that need sleeping disks"
        value={settings.wakePolicy}
        options={[
          { value: 'never', label: 'Never wake disks automatically' },
          { value: 'prompt', label: 'Ask before waking disks' },
          { value: 'auto', label: 'Wake disks automatically' }
        ]}
        onChange={(policy) => updateSettings({ wakePolicy: policy })}
      />
      
      <SettingSlider
        label="Monitoring Interval"
        description="How often to check disk power states"
        value={settings.monitoringInterval}
        min={10}
        max={300}
        step={10}
        unit="seconds"
        onChange={(interval) => updateSettings({ monitoringInterval: interval })}
      />
    </SettingsSection>
  )
}
```

### System Integration

**Disk Power Detection Commands**
```bash
# smartctl method (preferred)
smartctl -n standby -H /dev/sda
# Output: "Device is in STANDBY mode" or "Device is in ACTIVE or IDLE mode"

# hdparm method (fallback)
hdparm -C /dev/sda
# Output: "drive state is: active/idle" or "drive state is: standby"

# /sys/block method (Linux)
cat /proc/diskstats | grep sda
# Compare current vs previous I/O stats to detect activity
```

### Configuration Options
```env
# Opportunistic Execution Configuration
POWER_MONITORING_ENABLED=true                    # Enable power state monitoring
POWER_MONITORING_INTERVAL_SECONDS=30             # How often to check disk states
OPPORTUNISTIC_TASK_TIMEOUT_HOURS=24             # Move to scheduled after this time
OPPORTUNISTIC_BATCH_WINDOW_MINUTES=5            # Group related tasks within window
POWER_DETECTION_METHOD=smartctl                 # smartctl, hdparm, sysblock, auto
AUTO_WAKE_DISKS=false                           # Automatically wake disks for tasks
REQUIRE_ALL_DISKS_ACTIVE=true                   # All disks must be active vs. just required ones
POWER_STATE_CACHE_SECONDS=10                    # Cache power states to avoid excessive checks
```

## Validation & Testing

### Unit Tests
- [ ] Power state detection accuracy for various disk types
- [ ] Opportunistic task scheduling logic
- [ ] Task promotion and timeout handling
- [ ] Disk wake confirmation workflows
- [ ] Configuration setting persistence

### Integration Tests
- [ ] End-to-end opportunistic task execution
- [ ] Power state monitoring with real disks
- [ ] Task queue UI integration with power states
- [ ] Cross-platform power detection methods
- [ ] Error handling for unavailable tools

### Hardware Compatibility Tests
- [ ] SATA, SAS, NVMe, USB drive compatibility
- [ ] Different Linux distributions and kernel versions
- [ ] Disk hibernation and sleep mode detection
- [ ] RAID controller compatibility
- [ ] External disk enclosure support

## Dependencies

**Required Stories:**
- Story 2.1: Task Engine Foundation (task execution framework)
- Story 2.4: Task Queue UI (for displaying power states and opportunistic queues)
- Story 1.6: Power-Efficient Operation Framework (NFR1 compliance)

**System Dependencies:**
- `smartctl` binary for SMART disk monitoring
- `hdparm` for disk power management (Linux)
- `/sys/block` filesystem access (Linux)
- Appropriate disk device permissions

**Database Dependencies:**
- `disks.power_status` field (already in V4 schema)
- `disks.last_health_check` field (already in V4 schema)
- `tasks.execution_priority` field (already in V4 schema)

## Definition of Done

- [ ] Power monitoring service accurately detects disk power states
- [ ] Opportunistic tasks only execute when required disks are active
- [ ] Task queue UI displays power states and opportunistic task indicators
- [ ] User can configure power management preferences and disk wake policies
- [ ] Disk wake confirmation modals work correctly for immediate tasks
- [ ] Task promotion from opportunistic to immediate/scheduled works reliably
- [ ] Cross-platform power detection works on target Linux systems
- [ ] Performance impact of power monitoring is minimal (<1% CPU)
- [ ] Error handling gracefully manages missing tools or permissions
- [ ] Integration with existing task engine preserves all functionality
- [ ] All power management settings persist correctly
- [ ] Users can override opportunistic behavior when needed

## Success Metrics

- **Power Efficiency:** 90%+ reduction in unnecessary disk wake-ups
- **Task Completion:** 95%+ of opportunistic tasks complete within 48 hours
- **Accuracy:** 100% accurate power state detection when tools available
- **Performance:** <10ms overhead per task scheduling decision
- **User Control:** Users can configure behavior to match their preferences
- **Reliability:** System works correctly even when power detection fails

## Next Stories

This story enables:
- **Story 2.6:** Advanced Task Scheduling (complex scheduling with power awareness)
- **Epic 3 Stories:** Migration planning with power-efficient execution
- **Story 1.6 Enhancement:** Complete power-efficient operation compliance

## PRD Requirements Fulfilled

- **FR12:** "A conditional monitoring process shall run only when 'opportunistic' tasks are queued. This monitor will trigger task execution once it detects that all required source and destination disks are active."
- **NFR1 Power Efficiency:** Preserves disk lifespan by avoiding unnecessary spin-ups
- **User Control:** Provides configuration options for different power management preferences
- **System Intelligence:** Makes MediaMogul aware of hardware state for optimal operation


## File List

*To be populated during implementation*

## Dev Agent Record

### Implementation Notes
*To be populated during development*

### Completion Notes
*To be populated upon completion*

### Debug Log References
*To be populated if debugging required*

## QA Results

*To be populated during QA review*
