# Story 3.2: Advanced Organization Rules

## Story

As a user,
I want sophisticated file organization rules and automated tagging capabilities,
So that I can create intelligent migration plans that automatically organize my files by metadata, content type, date patterns, and custom criteria, ensuring my migrated data is perfectly structured for my needs.

## Story Context

**Epic:** 3 - Migration Planning and Execution  
**Dependencies:** Story 3.1 (Migration Planning Foundation), Epic 2 Complete (Task Engine, MD5, MediaInfo)  
**Story Type:** Core Feature - Advanced Organization  

This story extends the migration planning foundation with powerful organization rules that leverage MediaInfo metadata, file analysis, and user-defined criteria. It enables MediaMogul to automatically organize files during migration using complex rules, smart tagging, and content-aware structuring.

## Acceptance Criteria

### Organization Rule Engine
- [ ] **Rule-based organization:** Create complex rules combining multiple criteria (file type, size, date, metadata)
- [ ] **Condition matching:** Support AND/OR logic for combining multiple conditions
- [ ] **Priority system:** Rules processed in priority order with conflict resolution
- [ ] **Template library:** Pre-built organization templates for common scenarios
- [ ] **Rule validation:** Validate rules before application with preview functionality
- [ ] **Rule inheritance:** Parent rules that apply to subdirectories with override capability

### Media-Aware Organization
- [ ] **Video organization:** Organize by resolution, codec, duration, year, genre
- [ ] **Audio organization:** Organize by artist, album, year, genre, bitrate, format
- [ ] **Photo organization:** Organize by date taken, camera model, location, event tags
- [ ] **Document organization:** Organize by creation date, author, document type, size
- [ ] **Archive organization:** Handle compressed files, extract metadata where possible
- [ ] **Format conversion planning:** Plan format conversions during migration

### Smart Tagging System
- [ ] **Automated tagging:** Auto-generate tags based on file content, metadata, path patterns
- [ ] **Custom tag rules:** User-defined tagging rules based on any file attribute
- [ ] **Tag hierarchies:** Nested tag structures for complex categorization
- [ ] **Tag validation:** Ensure tag consistency and prevent duplicates
- [ ] **Bulk tagging:** Apply tags to groups of files matching criteria
- [ ] **Tag-based organization:** Use tags as organization criteria in rules

### Date-Based Organization
- [ ] **Date extraction:** Extract dates from filenames, metadata, and file timestamps
- [ ] **Date pattern matching:** Recognize various date formats and patterns
- [ ] **Date-based directories:** Create directory structures based on dates (YYYY/MM, etc.)
- [ ] **Date range filtering:** Organize files within specific date ranges
- [ ] **Missing date handling:** Strategy for files without discoverable dates
- [ ] **Date conflict resolution:** Handle files with multiple conflicting dates

### Content Analysis Integration
- [ ] **Duplicate grouping:** Group duplicates for intelligent handling decisions
- [ ] **Quality assessment:** Identify highest quality versions of similar files
- [ ] **Content similarity:** Group similar files even without exact MD5 matches
- [ ] **File health analysis:** Identify corrupted or damaged files for special handling
- [ ] **Size optimization:** Identify oversized files for compression or conversion
- [ ] **Format standardization:** Plan format conversions for consistency

### Directory Structure Templates
- [ ] **Template gallery:** Library of proven directory structure templates
- [ ] **Custom templates:** Create and save custom directory structure patterns
- [ ] **Dynamic directories:** Create directories based on file metadata
- [ ] **Nested structures:** Support multi-level directory hierarchies
- [ ] **Path length validation:** Ensure paths don't exceed filesystem limits
- [ ] **Character sanitization:** Handle special characters in directory names

### Preview and Simulation
- [ ] **Organization preview:** Preview organized structure before migration
- [ ] **Rule testing:** Test rules against sample files to verify behavior
- [ ] **Impact simulation:** Simulate organization impact on file distribution
- [ ] **Conflict identification:** Identify potential naming conflicts before migration
- [ ] **Space distribution:** Show how files will be distributed across directories
- [ ] **Before/after comparison:** Visual comparison of current vs. planned organization

## Technical Implementation

### Backend Components

**Organization Rule Engine** (`internal/services/organization_engine.go`)
```go
type OrganizationEngine struct {
    db           *database.DB
    mediaService *MediaInfoService
    fileService  *FileService
    logger       *slog.Logger
}

type OrganizationRule struct {
    ID              string                 `json:"id" db:"id"`
    Name            string                 `json:"name" db:"name"`
    Description     string                 `json:"description" db:"description"`
    Priority        int                    `json:"priority" db:"priority"`
    Conditions      []RuleCondition        `json:"conditions" db:"conditions"`
    Actions         []RuleAction           `json:"actions" db:"actions"`
    Tags            []string               `json:"tags" db:"tags"`
    Enabled         bool                   `json:"enabled" db:"enabled"`
    CreatedOn       int64                  `json:"created_on" db:"created_on"`
    UpdatedOn       int64                  `json:"updated_on" db:"updated_on"`
}

type RuleCondition struct {
    Field    string      `json:"field"`    // file_type, size, date_created, metadata.duration, etc.
    Operator string      `json:"operator"` // equals, contains, greater_than, less_than, matches_regex
    Value    interface{} `json:"value"`
    Logic    string      `json:"logic"`    // AND, OR (for next condition)
}

type RuleAction struct {
    Type       string                 `json:"type"`       // move_to_directory, add_tag, rename_file, convert_format
    Parameters map[string]interface{} `json:"parameters"`
}

func (e *OrganizationEngine) ApplyRules(ctx context.Context, files []File, rules []OrganizationRule) ([]OrganizedFile, error) {
    var organizedFiles []OrganizedFile
    
    // Sort rules by priority
    sort.Slice(rules, func(i, j int) bool {
        return rules[i].Priority < rules[j].Priority
    })
    
    for _, file := range files {
        organized := OrganizedFile{
            File:              file,
            OriginalPath:      file.Path,
            TargetPath:        file.Path,
            Tags:              []string{},
            OrganizationRules: []string{},
            Actions:           []PlannedAction{},
        }
        
        // Apply each rule in priority order
        for _, rule := range rules {
            if !rule.Enabled {
                continue
            }
            
            matches, err := e.evaluateConditions(ctx, file, rule.Conditions)
            if err != nil {
                e.logger.Error("Error evaluating rule conditions", "rule_id", rule.ID, "file", file.Path, "error", err)
                continue
            }
            
            if matches {
                actions, err := e.executeRuleActions(ctx, organized, rule.Actions)
                if err != nil {
                    e.logger.Error("Error executing rule actions", "rule_id", rule.ID, "file", file.Path, "error", err)
                    continue
                }
                
                organized.Actions = append(organized.Actions, actions...)
                organized.Tags = append(organized.Tags, rule.Tags...)
                organized.OrganizationRules = append(organized.OrganizationRules, rule.ID)
                
                e.logger.Debug("Rule applied", "rule_id", rule.ID, "file", file.Path)
            }
        }
        
        organizedFiles = append(organizedFiles, organized)
    }
    
    return organizedFiles, nil
}

func (e *OrganizationEngine) evaluateConditions(ctx context.Context, file File, conditions []RuleCondition) (bool, error) {
    if len(conditions) == 0 {
        return true, nil // No conditions means always match
    }
    
    var result bool
    var currentLogic string = "AND" // Default logic
    
    for i, condition := range conditions {
        match, err := e.evaluateCondition(ctx, file, condition)
        if err != nil {
            return false, err
        }
        
        if i == 0 {
            result = match
        } else {
            switch currentLogic {
            case "AND":
                result = result && match
            case "OR":
                result = result || match
            }
        }
        
        currentLogic = condition.Logic
    }
    
    return result, nil
}

func (e *OrganizationEngine) evaluateCondition(ctx context.Context, file File, condition RuleCondition) (bool, error) {
    fieldValue, err := e.getFieldValue(ctx, file, condition.Field)
    if err != nil {
        return false, err
    }
    
    switch condition.Operator {
    case "equals":
        return e.compareValues(fieldValue, condition.Value, "=="), nil
    case "not_equals":
        return !e.compareValues(fieldValue, condition.Value, "=="), nil
    case "contains":
        return e.stringContains(fieldValue, condition.Value), nil
    case "greater_than":
        return e.compareValues(fieldValue, condition.Value, ">"), nil
    case "less_than":
        return e.compareValues(fieldValue, condition.Value, "<"), nil
    case "matches_regex":
        return e.matchesRegex(fieldValue, condition.Value)
    case "in_list":
        return e.valueInList(fieldValue, condition.Value), nil
    default:
        return false, fmt.Errorf("unknown operator: %s", condition.Operator)
    }
}

func (e *OrganizationEngine) getFieldValue(ctx context.Context, file File, field string) (interface{}, error) {
    switch {
    case field == "file_type":
        return filepath.Ext(file.Name), nil
    case field == "size":
        return file.Size, nil
    case field == "name":
        return file.Name, nil
    case field == "path":
        return file.Path, nil
    case field == "date_created":
        return file.CreatedOn, nil
    case field == "date_modified":
        return file.UpdatedOn, nil
    case strings.HasPrefix(field, "metadata."):
        return e.getMetadataField(ctx, file, strings.TrimPrefix(field, "metadata."))
    case strings.HasPrefix(field, "tag."):
        return e.hasTag(ctx, file, strings.TrimPrefix(field, "tag."))
    default:
        return nil, fmt.Errorf("unknown field: %s", field)
    }
}

func (e *OrganizationEngine) executeRuleActions(ctx context.Context, organized OrganizedFile, actions []RuleAction) ([]PlannedAction, error) {
    var plannedActions []PlannedAction
    
    for _, action := range actions {
        switch action.Type {
        case "move_to_directory":
            targetDir, err := e.buildTargetDirectory(ctx, organized, action.Parameters)
            if err != nil {
                return nil, err
            }
            organized.TargetPath = filepath.Join(targetDir, organized.File.Name)
            plannedActions = append(plannedActions, PlannedAction{
                Type:        "move",
                Source:      organized.OriginalPath,
                Destination: organized.TargetPath,
                Parameters:  action.Parameters,
            })
            
        case "rename_file":
            newName, err := e.buildFileName(ctx, organized, action.Parameters)
            if err != nil {
                return nil, err
            }
            targetDir := filepath.Dir(organized.TargetPath)
            organized.TargetPath = filepath.Join(targetDir, newName)
            plannedActions = append(plannedActions, PlannedAction{
                Type:        "rename",
                Source:      organized.File.Name,
                Destination: newName,
                Parameters:  action.Parameters,
            })
            
        case "add_tag":
            if tagName, ok := action.Parameters["tag"].(string); ok {
                organized.Tags = append(organized.Tags, tagName)
                plannedActions = append(plannedActions, PlannedAction{
                    Type:       "tag",
                    Parameters: action.Parameters,
                })
            }
            
        case "convert_format":
            targetFormat, err := e.determineTargetFormat(ctx, organized, action.Parameters)
            if err != nil {
                return nil, err
            }
            plannedActions = append(plannedActions, PlannedAction{
                Type:        "convert",
                Source:      organized.TargetPath,
                Destination: e.changeFileExtension(organized.TargetPath, targetFormat),
                Parameters:  action.Parameters,
            })
        }
    }
    
    return plannedActions, nil
}
```

**Smart Tagging Service** (`internal/services/smart_tagger.go`)
```go
type SmartTaggerService struct {
    db              *database.DB
    mediaService    *MediaInfoService
    organizationEngine *OrganizationEngine
    logger          *slog.Logger
}

type TaggingRule struct {
    ID          string            `json:"id"`
    Name        string            `json:"name"`
    Description string            `json:"description"`
    Conditions  []RuleCondition   `json:"conditions"`
    TagTemplate string            `json:"tag_template"` // Template with placeholders like {year}, {genre}
    AutoApply   bool              `json:"auto_apply"`
    CreatedOn   int64             `json:"created_on"`
}

func (s *SmartTaggerService) GenerateAutomaticTags(ctx context.Context, file File) ([]string, error) {
    var tags []string
    
    // File type based tags
    ext := strings.ToLower(filepath.Ext(file.Name))
    switch ext {
    case ".mp4", ".avi", ".mkv", ".mov":
        tags = append(tags, "video")
    case ".mp3", ".flac", ".wav", ".m4a":
        tags = append(tags, "audio")
    case ".jpg", ".jpeg", ".png", ".gif", ".bmp":
        tags = append(tags, "image")
    case ".pdf", ".doc", ".docx", ".txt":
        tags = append(tags, "document")
    case ".zip", ".rar", ".7z", ".tar":
        tags = append(tags, "archive")
    }
    
    // Size-based tags
    if file.Size > 1*GB {
        tags = append(tags, "large-file")
    } else if file.Size < 1*MB {
        tags = append(tags, "small-file")
    }
    
    // Date-based tags
    if dateTag := s.extractDateTag(file); dateTag != "" {
        tags = append(tags, dateTag)
    }
    
    // Path-based tags
    pathTags := s.extractPathTags(file.Path)
    tags = append(tags, pathTags...)
    
    // Metadata-based tags
    if isMediaFile(ext) {
        metadataTags, err := s.extractMetadataTags(ctx, file)
        if err != nil {
            s.logger.Warn("Failed to extract metadata tags", "file", file.Path, "error", err)
        } else {
            tags = append(tags, metadataTags...)
        }
    }
    
    return s.deduplicateTags(tags), nil
}

func (s *SmartTaggerService) extractMetadataTags(ctx context.Context, file File) ([]string, error) {
    var tags []string
    
    // Get MediaInfo data if available
    mediaInfo, err := s.mediaService.GetMediaInfo(ctx, file.ID)
    if err != nil {
        return tags, err
    }
    
    if mediaInfo != nil {
        // Video-specific tags
        if mediaInfo.VideoStreams != nil && len(mediaInfo.VideoStreams) > 0 {
            video := mediaInfo.VideoStreams[0]
            
            // Resolution tags
            if video.Width != nil && video.Height != nil {
                if *video.Width >= 3840 {
                    tags = append(tags, "4k", "uhd")
                } else if *video.Width >= 1920 {
                    tags = append(tags, "1080p", "hd")
                } else if *video.Width >= 1280 {
                    tags = append(tags, "720p", "hd")
                } else {
                    tags = append(tags, "sd")
                }
            }
            
            // Codec tags
            if video.Codec != nil {
                tags = append(tags, "codec-"+strings.ToLower(*video.Codec))
            }
            
            // Duration tags
            if mediaInfo.Duration != nil {
                duration := *mediaInfo.Duration
                if duration > 7200 { // 2 hours
                    tags = append(tags, "long-video")
                } else if duration < 300 { // 5 minutes
                    tags = append(tags, "short-video")
                }
            }
        }
        
        // Audio-specific tags
        if mediaInfo.AudioStreams != nil && len(mediaInfo.AudioStreams) > 0 {
            audio := mediaInfo.AudioStreams[0]
            
            // Bitrate tags
            if audio.BitRate != nil {
                bitrate := *audio.BitRate
                if bitrate >= 320000 {
                    tags = append(tags, "high-quality-audio")
                } else if bitrate < 128000 {
                    tags = append(tags, "low-quality-audio")
                }
            }
            
            // Codec tags
            if audio.Codec != nil {
                tags = append(tags, "audio-"+strings.ToLower(*audio.Codec))
            }
        }
    }
    
    return tags, nil
}

func (s *SmartTaggerService) ApplyTaggingRules(ctx context.Context, files []File, rules []TaggingRule) (map[string][]string, error) {
    fileTags := make(map[string][]string)
    
    for _, file := range files {
        var allTags []string
        
        // Apply each tagging rule
        for _, rule := range rules {
            if !rule.AutoApply {
                continue
            }
            
            matches, err := s.organizationEngine.evaluateConditions(ctx, file, rule.Conditions)
            if err != nil {
                s.logger.Error("Error evaluating tagging rule", "rule_id", rule.ID, "file", file.Path, "error", err)
                continue
            }
            
            if matches {
                tag, err := s.processTagTemplate(ctx, file, rule.TagTemplate)
                if err != nil {
                    s.logger.Error("Error processing tag template", "rule_id", rule.ID, "template", rule.TagTemplate, "error", err)
                    continue
                }
                allTags = append(allTags, tag)
            }
        }
        
        fileTags[file.ID] = s.deduplicateTags(allTags)
    }
    
    return fileTags, nil
}

func (s *SmartTaggerService) processTagTemplate(ctx context.Context, file File, template string) (string, error) {
    result := template
    
    // Replace common placeholders
    result = strings.ReplaceAll(result, "{name}", file.Name)
    result = strings.ReplaceAll(result, "{ext}", filepath.Ext(file.Name))
    result = strings.ReplaceAll(result, "{size}", formatFileSize(file.Size))
    
    // Date placeholders
    createdTime := time.Unix(file.CreatedOn, 0)
    result = strings.ReplaceAll(result, "{year}", createdTime.Format("2006"))
    result = strings.ReplaceAll(result, "{month}", createdTime.Format("01"))
    result = strings.ReplaceAll(result, "{day}", createdTime.Format("02"))
    
    // Metadata placeholders (requires MediaInfo lookup)
    if strings.Contains(result, "{") && strings.Contains(result, "}") {
        mediaInfo, err := s.mediaService.GetMediaInfo(ctx, file.ID)
        if err == nil && mediaInfo != nil {
            result = s.replaceMetadataPlaceholders(result, mediaInfo)
        }
    }
    
    return result, nil
}
```

**Directory Structure Builder** (`internal/services/directory_builder.go`)
```go
type DirectoryStructureBuilder struct {
    templates map[string]DirectoryTemplate
    logger    *slog.Logger
}

type DirectoryTemplate struct {
    ID          string                    `json:"id"`
    Name        string                    `json:"name"`
    Description string                    `json:"description"`
    Structure   []DirectoryLevel          `json:"structure"`
    Variables   map[string]VariableConfig `json:"variables"`
}

type DirectoryLevel struct {
    Name        string            `json:"name"`        // Template with placeholders
    Conditions  []RuleCondition   `json:"conditions"`  // When to create this level
    MaxFiles    int               `json:"max_files"`   // Split directory if exceeded
    Fallback    string            `json:"fallback"`    // Fallback name if template fails
}

type VariableConfig struct {
    Source      string   `json:"source"`       // metadata, filename, date, etc.
    Field       string   `json:"field"`        // specific field name
    Format      string   `json:"format"`       // formatting template
    DefaultValue string  `json:"default_value"`
}

func (b *DirectoryStructureBuilder) BuildDirectoryPath(ctx context.Context, file File, template DirectoryTemplate) (string, error) {
    var pathComponents []string
    
    for _, level := range template.Structure {
        // Check if this level applies to this file
        if len(level.Conditions) > 0 {
            // Use organization engine to evaluate conditions
            // (implementation would delegate to OrganizationEngine)
        }
        
        // Process the directory name template
        dirName, err := b.processDirectoryTemplate(ctx, file, level.Name, template.Variables)
        if err != nil {
            if level.Fallback != "" {
                dirName = level.Fallback
            } else {
                return "", fmt.Errorf("failed to process directory template: %w", err)
            }
        }
        
        // Sanitize directory name
        dirName = b.sanitizeDirectoryName(dirName)
        if dirName != "" {
            pathComponents = append(pathComponents, dirName)
        }
    }
    
    return filepath.Join(pathComponents...), nil
}

func (b *DirectoryStructureBuilder) processDirectoryTemplate(ctx context.Context, file File, template string, variables map[string]VariableConfig) (string, error) {
    result := template
    
    // Find all placeholders in the template
    placeholders := b.extractPlaceholders(template)
    
    for _, placeholder := range placeholders {
        value, err := b.getVariableValue(ctx, file, placeholder, variables)
        if err != nil {
            return "", fmt.Errorf("failed to get value for placeholder %s: %w", placeholder, err)
        }
        
        result = strings.ReplaceAll(result, "{"+placeholder+"}", value)
    }
    
    return result, nil
}

// Pre-built directory templates
func (b *DirectoryStructureBuilder) GetBuiltinTemplates() map[string]DirectoryTemplate {
    return map[string]DirectoryTemplate{
        "media_by_year_type": {
            ID:   "media_by_year_type",
            Name: "Media by Year and Type",
            Structure: []DirectoryLevel{
                {Name: "{year}", Conditions: []RuleCondition{{Field: "file_type", Operator: "in_list", Value: []string{".mp4", ".avi", ".mkv", ".mp3", ".flac"}}}},
                {Name: "{media_type}", Fallback: "other"},
                {Name: "{quality_tier}", Conditions: []RuleCondition{{Field: "metadata.resolution", Operator: "greater_than", Value: "1080p"}}},
            },
            Variables: map[string]VariableConfig{
                "year":         {Source: "date", Field: "created", Format: "2006"},
                "media_type":   {Source: "metadata", Field: "type"},
                "quality_tier": {Source: "metadata", Field: "resolution", Format: "quality_name"},
            },
        },
        "documents_by_date_type": {
            ID:   "documents_by_date_type",
            Name: "Documents by Date and Type",
            Structure: []DirectoryLevel{
                {Name: "{year}"},
                {Name: "{month_name}"},
                {Name: "{document_type}", Fallback: "other"},
            },
            Variables: map[string]VariableConfig{
                "year":          {Source: "date", Field: "created", Format: "2006"},
                "month_name":    {Source: "date", Field: "created", Format: "January"},
                "document_type": {Source: "extension", Field: "type", Format: "title_case"},
            },
        },
        "photos_by_date_event": {
            ID:   "photos_by_date_event",
            Name: "Photos by Date and Event",
            Structure: []DirectoryLevel{
                {Name: "{year}"},
                {Name: "{month_year}"},
                {Name: "{event_name}", Fallback: "general"},
            },
            Variables: map[string]VariableConfig{
                "year":       {Source: "metadata", Field: "date_taken", Format: "2006", DefaultValue: "unknown"},
                "month_year": {Source: "metadata", Field: "date_taken", Format: "2006-01"},
                "event_name": {Source: "path", Field: "parent_directory"},
            },
        },
    }
}
```

### API Endpoints

**Organization Rules API** (`internal/api/organization_rules.go`)
```go
// POST /api/v1/organization-rules
func (h *OrganizationHandler) CreateRule(c *gin.Context) {
    var req CreateRuleRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "Invalid request body"})
        return
    }
    
    rule, err := h.orgService.CreateRule(c.Request.Context(), req)
    if err != nil {
        h.logger.Error("Failed to create organization rule", "error", err)
        c.JSON(500, gin.H{"error": "Failed to create rule"})
        return
    }
    
    c.JSON(201, rule)
}

// POST /api/v1/organization-rules/test
func (h *OrganizationHandler) TestRules(c *gin.Context) {
    var req TestRulesRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "Invalid request body"})
        return
    }
    
    results, err := h.orgService.TestRules(c.Request.Context(), req.Files, req.Rules)
    if err != nil {
        h.logger.Error("Failed to test rules", "error", err)
        c.JSON(500, gin.H{"error": "Failed to test rules"})
        return
    }
    
    c.JSON(200, gin.H{"results": results})
}

// GET /api/v1/directory-templates
func (h *OrganizationHandler) GetDirectoryTemplates(c *gin.Context) {
    templates := h.structureBuilder.GetBuiltinTemplates()
    
    // Add custom user templates
    customTemplates, err := h.orgService.GetUserTemplates(c.Request.Context())
    if err != nil {
        h.logger.Error("Failed to get user templates", "error", err)
    } else {
        for id, template := range customTemplates {
            templates[id] = template
        }
    }
    
    c.JSON(200, gin.H{"templates": templates})
}

// POST /api/v1/organization/preview
func (h *OrganizationHandler) PreviewOrganization(c *gin.Context) {
    var req PreviewOrganizationRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "Invalid request body"})
        return
    }
    
    preview, err := h.orgService.PreviewOrganization(c.Request.Context(), req)
    if err != nil {
        h.logger.Error("Failed to preview organization", "error", err)
        c.JSON(500, gin.H{"error": "Failed to preview organization"})
        return
    }
    
    c.JSON(200, preview)
}
```

### Frontend Components

**Organization Rules Manager** (`app/organization/rules/page.tsx`)
```tsx
'use client'
export default function OrganizationRulesPage() {
  const { rules, isLoading, createRule, updateRule, deleteRule, testRules } = useOrganizationRules()
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false)
  const [selectedRule, setSelectedRule] = useState<OrganizationRule | null>(null)
  
  return (
    <div className="organization-rules-container">
      <div className="page-header">
        <h1>Organization Rules</h1>
        <div className="header-actions">
          <Button 
            variant="outline"
            onClick={() => setIsTestDialogOpen(true)}
          >
            Test Rules
          </Button>
          <Button onClick={() => setIsCreateDialogOpen(true)}>
            Create Rule
          </Button>
        </div>
      </div>
      
      <RulesList 
        rules={rules}
        isLoading={isLoading}
        onEdit={setSelectedRule}
        onDelete={deleteRule}
        onTest={testRules}
      />
      
      <CreateRuleDialog
        isOpen={isCreateDialogOpen}
        onClose={() => setIsCreateDialogOpen(false)}
        onCreateRule={createRule}
      />
      
      {selectedRule && (
        <EditRuleDialog
          rule={selectedRule}
          isOpen={!!selectedRule}
          onClose={() => setSelectedRule(null)}
          onUpdateRule={updateRule}
        />
      )}
    </div>
  )
}
```

**Rule Builder Component** (`components/organization/RuleBuilder.tsx`)
```tsx
export function RuleBuilder({ rule, onChange }: RuleBuilderProps) {
  const [conditions, setConditions] = useState<RuleCondition[]>(rule.conditions || [])
  const [actions, setActions] = useState<RuleAction[]>(rule.actions || [])
  
  const addCondition = () => {
    setConditions([...conditions, {
      field: 'file_type',
      operator: 'equals',
      value: '',
      logic: 'AND'
    }])
  }
  
  const addAction = () => {
    setActions([...actions, {
      type: 'move_to_directory',
      parameters: {}
    }])
  }
  
  return (
    <div className="rule-builder">
      <div className="rule-section">
        <h3>Conditions</h3>
        <p className="section-description">Define when this rule should apply</p>
        
        {conditions.map((condition, index) => (
          <ConditionBuilder
            key={index}
            condition={condition}
            onChange={(updated) => {
              const newConditions = [...conditions]
              newConditions[index] = updated
              setConditions(newConditions)
            }}
            onRemove={() => {
              setConditions(conditions.filter((_, i) => i !== index))
            }}
            showLogic={index > 0}
          />
        ))}
        
        <Button variant="outline" onClick={addCondition}>
          Add Condition
        </Button>
      </div>
      
      <div className="rule-section">
        <h3>Actions</h3>
        <p className="section-description">Define what should happen when conditions match</p>
        
        {actions.map((action, index) => (
          <ActionBuilder
            key={index}
            action={action}
            onChange={(updated) => {
              const newActions = [...actions]
              newActions[index] = updated
              setActions(newActions)
            }}
            onRemove={() => {
              setActions(actions.filter((_, i) => i !== index))
            }}
          />
        ))}
        
        <Button variant="outline" onClick={addAction}>
          Add Action
        </Button>
      </div>
      
      <div className="rule-section">
        <h3>Preview</h3>
        <RulePreview conditions={conditions} actions={actions} />
      </div>
    </div>
  )
}
```

**Organization Preview** (`components/organization/OrganizationPreview.tsx`)
```tsx
export function OrganizationPreview({ previewData }: { previewData: OrganizationPreviewData }) {
  const [viewMode, setViewMode] = useState<'tree' | 'list'>('tree')
  
  return (
    <div className="organization-preview">
      <div className="preview-header">
        <h3>Organization Preview</h3>
        <div className="view-controls">
          <ToggleGroup type="single" value={viewMode} onValueChange={setViewMode}>
            <ToggleGroupItem value="tree">Tree View</ToggleGroupItem>
            <ToggleGroupItem value="list">List View</ToggleGroupItem>
          </ToggleGroup>
        </div>
      </div>
      
      <div className="preview-stats">
        <StatCard title="Files to Organize" value={previewData.totalFiles} />
        <StatCard title="Directories Created" value={previewData.directoriesCreated} />
        <StatCard title="Conflicts Detected" value={previewData.conflicts.length} />
        <StatCard title="Rules Applied" value={previewData.rulesApplied} />
      </div>
      
      {previewData.conflicts.length > 0 && (
        <Alert variant="warning">
          <AlertTriangle className="h-4 w-4" />
          <AlertTitle>Conflicts Detected</AlertTitle>
          <AlertDescription>
            {previewData.conflicts.length} naming conflicts need resolution before migration.
          </AlertDescription>
        </Alert>
      )}
      
      <div className="preview-content">
        {viewMode === 'tree' ? (
          <DirectoryTreeView data={previewData.directoryStructure} />
        ) : (
          <FileListView files={previewData.organizedFiles} />
        )}
      </div>
    </div>
  )
}
```

### Database Schema

**Organization Rules Tables** (`migrations/009_organization_rules.sql`)
```sql
CREATE TABLE organization_rules (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    priority INTEGER NOT NULL DEFAULT 0,
    conditions TEXT NOT NULL, -- JSON array of RuleCondition
    actions TEXT NOT NULL,    -- JSON array of RuleAction
    tags TEXT,                -- JSON array of strings
    enabled BOOLEAN NOT NULL DEFAULT true,
    created_on INTEGER NOT NULL,
    updated_on INTEGER NOT NULL
);

CREATE INDEX idx_organization_rules_priority ON organization_rules(priority);
CREATE INDEX idx_organization_rules_enabled ON organization_rules(enabled);

CREATE TABLE directory_templates (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    structure TEXT NOT NULL,  -- JSON DirectoryTemplate
    variables TEXT NOT NULL,  -- JSON map of VariableConfig
    builtin BOOLEAN NOT NULL DEFAULT false,
    created_on INTEGER NOT NULL,
    updated_on INTEGER NOT NULL
);

CREATE TABLE file_tags (
    file_id TEXT NOT NULL REFERENCES files(id) ON DELETE CASCADE,
    tag TEXT NOT NULL,
    source TEXT NOT NULL, -- 'manual', 'automatic', 'rule:{rule_id}'
    created_on INTEGER NOT NULL,
    PRIMARY KEY (file_id, tag)
);

CREATE INDEX idx_file_tags_tag ON file_tags(tag);
CREATE INDEX idx_file_tags_source ON file_tags(source);

CREATE TABLE tagging_rules (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    conditions TEXT NOT NULL,   -- JSON array of RuleCondition
    tag_template TEXT NOT NULL, -- Template string with placeholders
    auto_apply BOOLEAN NOT NULL DEFAULT false,
    created_on INTEGER NOT NULL
);
```

## Validation & Testing

### Rule Engine Tests
- [ ] Condition evaluation accuracy with various file types
- [ ] Rule priority and conflict resolution
- [ ] Action execution and path generation
- [ ] Template processing with metadata
- [ ] Performance with large rule sets

### Organization Tests
- [ ] Directory structure generation
- [ ] File naming and conflict resolution
- [ ] Tag application and inheritance
- [ ] Preview accuracy vs. actual results
- [ ] Edge cases and error handling

### UI Tests
- [ ] Rule builder interface functionality
- [ ] Preview visualization accuracy
- [ ] Template gallery and custom templates
- [ ] Responsive design and accessibility
- [ ] Complex rule creation workflows

## Dependencies

**Required Stories:**
- Story 3.1: Migration Planning Foundation
- Epic 2 Complete: Task Engine, MD5, MediaInfo, UI, Opportunistic Logic
- Story 1.3: File System Scanning & Cataloging

**Technical Dependencies:**
- MediaInfo metadata for content-aware organization
- MD5 checksums for duplicate detection
- File system scanning for path analysis
- Tag system for classification

## Definition of Done

- [ ] Rule engine supports complex multi-condition rules with AND/OR logic
- [ ] Media-aware organization using MediaInfo metadata
- [ ] Smart tagging system with automatic and rule-based tagging
- [ ] Date-based organization with multiple date source recognition
- [ ] Directory structure templates with built-in and custom options
- [ ] Organization preview with conflict detection
- [ ] Rule testing interface for validation before application
- [ ] Complete UI for rule management and template configuration
- [ ] API endpoints for all organization operations
- [ ] Database schema for rules, templates, and tags
- [ ] Integration with migration planning system

## Success Metrics

- **Organization Accuracy:** 95%+ of files organized correctly according to rules
- **Rule Performance:** Process 10K+ files in under 30 seconds
- **User Adoption:** Users create average of 5+ custom organization rules
- **Conflict Resolution:** Less than 1% naming conflicts in organized structures
- **Preview Accuracy:** 99%+ match between preview and actual organization

## Next Stories

This story enables:
- **Story 3.3:** Migration Execution Engine (applying organization rules during migration)
- **Story 3.4:** Migration Monitoring & Control (monitoring organization progress)
- **Story 3.5:** Post-Migration Validation (validating organization results)

## PRD Requirements Fulfilled

- **FR3:** User-defined organization rules and intelligent file structuring
- **FR4:** Advanced duplicate detection and handling strategies
- **FR5:** Media-aware organization using metadata analysis
- **Smart Organization:** Automated tagging and content-aware file organization
- **Template System:** Reusable organization patterns for common use cases


## File List

*To be populated during implementation*

## Dev Agent Record

### Implementation Notes
*To be populated during development*

### Completion Notes
*To be populated upon completion*

### Debug Log References
*To be populated if debugging required*

## QA Results

*To be populated during QA review*
