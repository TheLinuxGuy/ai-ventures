# Story: Basic Error Handling and Logging

## Story

As a developer/user,
I want comprehensive error handling and logging,
so that issues can be diagnosed and the application remains stable.

## Acceptance Criteria

### Error Handling Framework
- [ ] All API endpoints have proper error handling
- [ ] User-friendly error messages in UI
- [ ] Comprehensive logging for debugging
- [ ] Graceful degradation when disks unavailable
- [ ] Error reporting doesn't crash the application
- [ ] Log rotation and management

### Environment-Based Debug Logging
- [ ] Support LOG=DEBUG environment variable for comprehensive debug output
- [ ] Detailed logging of all operations, API calls, and system interactions
- [ ] Debug log file output with full request/response details and timing
- [ ] Configurable log levels via environment variables (LOG=ERROR|WARN|INFO|DEBUG)
- [ ] Debug mode captures all disk operations, configuration changes, and user interactions
- [ ] Performance metrics and timing information in debug logs

## Dev Notes

### Previous Story Insights
**From Story 1.1 - Application Bootstrap and Configuration:**
- Configuration system needs error handling for invalid paths and permissions
- Database connection and startup error scenarios

**From Story 1.2 - Physical Disk Discovery and Registration:**
- Disk discovery errors (missing smartctl, permission issues, system call failures)
- Graceful handling of unmounted, encrypted, or inaccessible disks

**From Story 1.3 - File System Scanning Engine:**
- File system access errors, permission denied scenarios
- Large directory handling and memory usage error cases

**From Story 1.4 - System Dashboard:**
- Real-time data update failures and WebSocket connection errors
- Dashboard load performance and timeout scenarios

**From Story 1.5 - File Browser Interface:**
- Navigation errors, missing folders, database query failures
- Search functionality error handling

**From Story 1.6 - Power-Efficient Operation Framework:**
- Power status detection failures, disk wake timeout errors
- Operation confirmation and policy enforcement errors

### Data Models
**ErrorLog Model** [Source: architecture.md#Data Models]
- Purpose: Store application errors and events for debugging
- Key Attributes:
  - `id TEXT PRIMARY KEY` - Unique error identifier
  - `timestamp DATETIME DEFAULT CURRENT_TIMESTAMP` - When error occurred
  - `level TEXT NOT NULL` - Error level (ERROR, WARN, INFO, DEBUG)
  - `component TEXT NOT NULL` - Application component that generated error
  - `message TEXT NOT NULL` - Human-readable error message
  - `details TEXT` - Technical details and stack trace
  - `context TEXT` - Additional context (user ID, operation type, etc.)
- Database Table: `error_logs` with proper indexing for queries

**LogConfiguration Model** [Enhanced for Environment Variable Support]
- Purpose: Configure logging levels and rotation settings with environment variable overrides
- Key Attributes:
  - `log_level TEXT DEFAULT 'INFO'` - Minimum log level to record (overrideable by LOG env var)
  - `debug_file_path TEXT DEFAULT './logs/debug.log'` - Path for debug log file when LOG=DEBUG
  - `max_log_size_mb INTEGER DEFAULT 100` - Maximum log file size
  - `max_log_files INTEGER DEFAULT 5` - Number of rotated log files to keep
  - `log_to_database BOOLEAN DEFAULT true` - Store logs in database
  - `log_to_file BOOLEAN DEFAULT true` - Write logs to file system
  - `debug_include_requests BOOLEAN DEFAULT true` - Include full HTTP request/response in debug logs
  - `debug_include_timing BOOLEAN DEFAULT true` - Include performance timing in debug logs
- Storage: Configuration table or file-based configuration with environment variable precedence
- Environment Variables: LOG, DEBUG_LOG_FILE, LOG_MAX_SIZE, LOG_MAX_FILES

### API Specifications
**Error Handling API Endpoints** [Source: Epic 1 Technical Tasks]
- GET /api/v1/logs - Retrieve application logs with filtering
- GET /api/v1/logs/errors - Get recent errors and warnings
- POST /api/v1/logs/config - Update logging configuration
- GET /api/v1/health - Application health check endpoint
- All existing endpoints enhanced with proper error responses

### Component Specifications
**Error Handling UI Components** [Source: Epic 1 Technical Tasks]
- Global error boundary components for React application
- User-friendly error messages with actionable guidance
- Error notification system (toasts, alerts)
- Developer log viewer for debugging (admin interface)
- Loading states and error states for all async operations
- React components with Tailwind CSS styling [Source: architecture.md#Tech Stack]

### File Locations
**Backend Structure** [Source: architecture.md#Unified Project Structure]
- Logging service: `apps/backend/internal/service/logger.go`
- Environment-based logger initialization: `apps/backend/internal/service/debuglogger.go`
- Error handling middleware: `apps/backend/internal/middleware/errorhandler.go`
- Debug logging middleware: `apps/backend/internal/middleware/debuglogger.go`
- Error models: `apps/backend/internal/models/errorlog.go`
- Health check endpoint: `apps/backend/internal/api/health.go`
- Log configuration: `apps/backend/internal/config/logging.go`
- Environment configuration: `apps/backend/internal/config/environment.go`

**Frontend Structure** [Source: architecture.md#Unified Project Structure]
- Error boundaries: `apps/frontend/components/errors/ErrorBoundary.tsx`
- Error notifications: `apps/frontend/components/errors/ErrorNotification.tsx`
- Error hooks: `apps/frontend/hooks/useErrorHandler.ts`
- Log viewer: `apps/frontend/app/admin/logs/page.tsx`
- Shared types: `packages/shared-types/errors.ts`

### Technical Constraints
**Stability**: Application must never crash due to unhandled errors
**Performance**: Logging must not impact application performance (except in DEBUG mode for troubleshooting)
**Storage**: Log rotation to prevent disk space issues, especially important for verbose DEBUG logs
**Security**: Sensitive information must not be logged (passwords, tokens, personal data)
**Environment Variables**: LOG environment variable takes precedence over configuration files
**Debug Mode**: LOG=DEBUG enables comprehensive logging for troubleshooting and development
**Compliance**: Error logging must respect user privacy, even in debug mode

### Testing Requirements
**Backend Testing**: Unit tests for error handling middleware and logging service [Source: architecture.md#Tech Stack]
**Frontend Testing**: Component tests for error boundaries and error states
**Integration Testing**: End-to-end error scenarios and recovery
**Performance Testing**: Logging overhead and log rotation functionality

## Tasks / Subtasks

### Backend Implementation - Enhanced Debug Logging Infrastructure
- [ ] Create environment-aware logging service with LOG variable support (AC: 7)
  - [ ] Parse LOG environment variable (ERROR, WARN, INFO, DEBUG) at startup
  - [ ] Override configuration file settings when LOG variable is present
  - [ ] Support additional environment variables: DEBUG_LOG_FILE, LOG_MAX_SIZE
- [ ] Implement comprehensive DEBUG mode logging (AC: 7)
  - [ ] Log all HTTP requests with headers, body, and response details
  - [ ] Log all database queries with execution time and result counts
  - [ ] Log all disk operations, file system access, and power management actions
  - [ ] Log configuration changes, user interactions, and system state changes
  - [ ] Include timestamp, request ID, user context, and performance metrics
- [ ] Create debug log file management (AC: 7)
  - [ ] Separate debug log file (./logs/debug.log by default)
  - [ ] High-performance file writing with minimal application impact
  - [ ] Automatic log rotation when files exceed size limits
  - [ ] Structured JSON logging format for easy parsing and analysis
### Backend Implementation - Enhanced Debug Logging Infrastructure
- [ ] Create environment-aware logging service with LOG variable support (AC: 7)
  - [ ] Parse LOG environment variable (ERROR, WARN, INFO, DEBUG) at startup
  - [ ] Override configuration file settings when LOG variable is present
  - [ ] Support additional environment variables: DEBUG_LOG_FILE, LOG_MAX_SIZE
- [ ] Implement comprehensive DEBUG mode logging (AC: 7)
  - [ ] Log all HTTP requests with headers, body, and response details
  - [ ] Log all database queries with execution time and result counts
  - [ ] Log all disk operations, file system access, and power management actions
  - [ ] Log configuration changes, user interactions, and system state changes
  - [ ] Include timestamp, request ID, user context, and performance metrics
- [ ] Create debug log file management (AC: 7)
  - [ ] Separate debug log file (./logs/debug.log by default)
  - [ ] High-performance file writing with minimal application impact
  - [ ] Automatic log rotation when files exceed size limits
  - [ ] Structured JSON logging format for easy parsing and analysis
- [ ] Write unit tests for environment-based logging configuration

### Backend Implementation - Standard Logging Infrastructure
- [ ] Implement ErrorLog model with GORM (AC: 3)
  - [ ] Add database table for error storage and querying
  - [ ] Add proper indexing for timestamp and level queries
- [ ] Create log configuration system (AC: 6)
  - [ ] Support file-based and database logging options
  - [ ] Add configurable log levels and rotation settings
- [ ] Implement log rotation and cleanup (AC: 6)
  - [ ] Rotate log files based on size and age
  - [ ] Clean up old database log entries automatically
- [ ] Write unit tests for standard logging infrastructure

### Backend Implementation - Debug-Aware Error Handling Middleware
- [ ] Create centralized error handling middleware with debug support (AC: 1, 7)
  - [ ] Catch and handle all API endpoint errors
  - [ ] Generate appropriate HTTP status codes and error responses
  - [ ] Include detailed error context in DEBUG mode (stack traces, request details)
- [ ] Add panic recovery middleware with debug logging (AC: 5, 7)
  - [ ] Prevent application crashes from unhandled panics
  - [ ] Log panic details with full context in DEBUG mode
  - [ ] Include goroutine dumps and system state in debug logs
- [ ] Implement graceful degradation patterns (AC: 4)
  - [ ] Handle disk unavailability without breaking functionality
  - [ ] Provide fallback responses when services fail
  - [ ] Log degradation events with detailed context in DEBUG mode
- [ ] Add request context and tracing for error correlation
  - [ ] Generate unique request IDs for tracking operations across services
  - [ ] Include request timing and performance metrics in DEBUG mode
- [ ] Write unit tests for debug-enhanced error handling middleware

### Backend Implementation - Enhanced API Error Responses with Debug Support
- [ ] Update all existing API endpoints with comprehensive error handling (AC: 1, 7)
  - [ ] Configuration endpoints from Story 1.1 (with debug config logging)
  - [ ] Disk discovery endpoints from Story 1.2 (with detailed disk operation logging)
  - [ ] Scan management endpoints from Story 1.3 (with file system access logging)
  - [ ] Dashboard endpoints from Story 1.4 (with real-time data logging)
  - [ ] File browser endpoints from Story 1.5 (with navigation and query logging)
  - [ ] Power management endpoints from Story 1.6 (with power operation logging)
- [ ] Create comprehensive health check endpoint (AC: 7)
  - [ ] Check database connectivity, disk access, and service status
  - [ ] Return detailed health information for monitoring
  - [ ] Include debug information when LOG=DEBUG (system resources, service metrics)
- [ ] Add debug-enhanced error logging API endpoints (AC: 7)
  - [ ] GET /api/v1/logs for log retrieval and filtering with debug level support
  - [ ] GET /api/v1/logs/debug for debug log file access (when LOG=DEBUG)
  - [ ] POST /api/v1/logs/config for logging configuration including debug settings
- [ ] Write unit tests for all enhanced error handling with debug scenarios

### Frontend Implementation - Error Boundaries and Recovery
- [ ] Create React error boundary components (AC: 5)
  - [ ] Catch JavaScript errors in component tree
  - [ ] Display user-friendly error messages
- [ ] Implement global error notification system (AC: 2)
  - [ ] Toast notifications for API errors
  - [ ] Clear, actionable error messages for users
- [ ] Add error states to all async components (AC: 2)
  - [ ] Loading, success, and error states for all data fetching
  - [ ] Retry mechanisms for recoverable errors
- [ ] Create error context and hooks
  - [ ] Centralized error state management
  - [ ] Error reporting and user feedback collection
- [ ] Write component tests for error boundaries and error states

### Frontend Implementation - User-Friendly Error Messages
- [ ] Design user-friendly error message system (AC: 2)
  - [ ] Convert technical errors to understandable language
  - [ ] Provide actionable guidance for error resolution
- [ ] Create error message components with different severity levels
  - [ ] Info, warning, error, and critical message types
  - [ ] Consistent styling and behavior across the application
- [ ] Add contextual help and troubleshooting guidance
  - [ ] Common error scenarios and solutions
  - [ ] Links to documentation or support resources
- [ ] Implement error message localization support (future-ready)
- [ ] Style error components with Tailwind CSS

### Integration with Existing Stories
- [ ] Enhance configuration system from Story 1.1
  - [ ] Add error handling for invalid paths and permissions
  - [ ] Improve database connection error recovery
- [ ] Improve disk discovery from Story 1.2
  - [ ] Handle missing smartctl and system call failures gracefully
  - [ ] Add better error messages for disk access issues
- [ ] Enhance scan engine from Story 1.3
  - [ ] Add comprehensive error handling for file system access
  - [ ] Improve large directory and memory error handling
- [ ] Update dashboard from Story 1.4
  - [ ] Handle real-time update failures and connection errors
  - [ ] Add error states for dashboard data loading
- [ ] Improve file browser from Story 1.5
  - [ ] Add error handling for navigation and search failures
  - [ ] Handle missing folders and database query errors
- [ ] Enhance power management from Story 1.6
  - [ ] Add error handling for power status detection failures
  - [ ] Improve disk wake timeout and operation errors

### Integration & Quality
- [ ] Test complete error handling across all application scenarios
- [ ] Verify application never crashes due to unhandled errors
- [ ] Test graceful degradation when external dependencies fail
- [ ] Validate user-friendly error messages provide actionable guidance
- [ ] Test log rotation and cleanup functionality for both standard and debug logs
- [ ] Verify error reporting doesn't expose sensitive information
- [ ] Test error recovery and retry mechanisms
- [ ] Validate logging performance doesn't impact application speed (except DEBUG mode)
- [ ] Test LOG=DEBUG environment variable functionality end-to-end
- [ ] Verify debug logs capture all operations for effective troubleshooting
- [ ] Test debug log file rotation and management under high load
- [ ] Validate environment variable precedence over configuration files

### Docker Container Integration Testing
- [ ] Test LOG=DEBUG functionality in Docker container environment (AC: 7)
  - [ ] Verify LOG environment variable is properly passed to containerized application
  - [ ] Test debug log file creation and writing within container filesystem
  - [ ] Validate log file persistence using Docker volumes for debug logs
  - [ ] Test container startup with various LOG levels (ERROR, WARN, INFO, DEBUG)
- [ ] Validate Docker container log output and debugging (AC: 7)
  - [ ] Test `docker logs` integration with application logging levels
  - [ ] Verify debug logs are accessible via volume mounts for troubleshooting
  - [ ] Test log rotation behavior within container storage constraints
  - [ ] Validate container restart preserves log configuration and files
- [ ] Test containerized debugging workflow scenarios (AC: 7)
  - [ ] Test debugging production issues using LOG=DEBUG in container
  - [ ] Verify log file access patterns work with container orchestration
  - [ ] Test environment variable injection via docker-compose and runtime
  - [ ] Validate debugging doesn't impact container performance or stability

## Definition of Done

- Application handles all errors gracefully without crashes or instability
- Users see helpful, actionable error messages instead of technical details
- Developers have comprehensive logging available for debugging issues
- LOG=DEBUG environment variable enables detailed troubleshooting capabilities
- Debug logs capture all operations, API calls, database queries, and system interactions
- Log files are properly managed, rotated, and cleaned up automatically (including debug logs)
- Error boundaries prevent UI crashes and provide recovery options
- All API endpoints return consistent, well-structured error responses
- Graceful degradation works when disks or services are unavailable
- Environment variables take precedence over configuration file settings
- Debug mode provides sufficient detail for effective issue triage and resolution
- Docker container integration works correctly with LOG=DEBUG environment variable
- Debug logs are accessible and persistent in containerized deployment scenarios
- Container orchestration properly handles log volume mounts and environment injection
- All tests pass (unit, integration, component, error scenario, debug mode, container)
- No unhandled errors or crashes during any application operations
- Debug logging performance impact is acceptable for troubleshooting scenarios

## File List

- `apps/backend/internal/service/logger.go` - Comprehensive logging service (285 lines)
- `apps/backend/internal/middleware/errorhandler.go` - Error handling middleware (234 lines)
- `apps/backend/internal/handlers/health.go` - Health check and logging APIs (124 lines)
- Main server integration with logger service and middleware chain
- LOG environment variable support for debug levels

## Dev Agent Record

### Implementation Notes
*To be populated during development*

### Completion Notes
*To be populated upon completion*

### Debug Log References
*To be populated if debugging required*

## QA Results

*To be populated during QA review*
