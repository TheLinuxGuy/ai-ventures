# Story 2.1: Asynchronous Task Engine Foundation

## Story

As a MediaMogul system,
I want a robust asynchronous task engine that can manage background operations with multiple execution priorities,
So that I can perform long-running I/O operations without blocking the user interface and efficiently manage system resources.

## Story Context

**Epic:** 2 - Asynchronous Task Engine & Data Enrichment  
**Dependencies:** Story 1.1 (Configuration), Story 1.2 (Disk Discovery), Story 1.3 (File System Scanning)  
**Story Type:** Foundation - Core Infrastructure  

This story establishes the foundational task engine that enables all background operations in MediaMogul. It implements the unified task system defined in the V4 data model and provides the infrastructure for MD5 calculation, MediaInfo extraction, file migration, and other asynchronous operations.

## Acceptance Criteria

### Core Task Engine
- [ ] Task creation API supports basic task types (md5 implemented, others TODOs)
- [ ] Task execution with three priority modes: immediate, opportunistic, scheduled (only basic priority exists)
- [ ] Task status management: pending → executing → complete/failed/cancelled
- [ ] Task dependency support (depends_on_task_uid) (not implemented)
- [ ] Concurrent task execution with configurable worker pool size (basic goroutine execution)
- [ ] Task progress tracking (progress_percent, files_processed, bytes_processed) (basic progress field exists)

### Task Persistence & Recovery
- [ ] All task data persists in SQLite using V4 task schema
- [ ] System recovery detects and handles stale/abandoned tasks on startup (not implemented)
- [ ] Process ID tracking for task ownership and cleanup (not implemented)
- [ ] Task error handling with detailed error messages
- [ ] Task cancellation support with proper cleanup (not implemented)

### Execution Priority Logic
- [ ] **Immediate tasks:** Execute as soon as worker available (basic execution exists, no priority logic)
- [ ] **Opportunistic tasks:** Execute only when required disks are active (not implemented)
- [ ] **Scheduled tasks:** Execute at specified time (scheduled_time field) (field exists, logic not implemented)
- [ ] Priority queue management ensures immediate tasks take precedence (basic ordering by priority)
- [ ] Disk power status integration for opportunistic task decisions (not implemented)

### API Endpoints
- [ ] `POST /api/v1/tasks` - Create new task (not implemented)
- [ ] `GET /api/v1/tasks` - List tasks with filtering (status, type, priority) (not implemented)
- [ ] `GET /api/v1/tasks/{uid}` - Get specific task details (not implemented)
- [ ] `PUT /api/v1/tasks/{uid}/cancel` - Cancel pending/executing task (not implemented)
- [ ] `DELETE /api/v1/tasks/{uid}` - Delete completed/failed task (not implemented)
- [ ] `GET /api/v1/tasks/stats` - Task queue statistics (not implemented)

### Task Execution Framework
- [ ] Worker pool with configurable concurrency (default: 3 workers) (basic goroutine execution)
- [ ] Task execution isolation (each task runs in separate goroutine)
- [ ] Proper resource cleanup after task completion
- [ ] Task timeout handling for long-running operations (not implemented)
- [ ] Memory management for large task payloads (not implemented)

## Technical Implementation

### Database Schema
Uses the existing V4 tasks table:
```sql
-- Already defined in architecture.md V4 schema
CREATE TABLE tasks (
    uid TEXT PRIMARY KEY,
    task_type TEXT NOT NULL,
    execution_priority TEXT NOT NULL,
    status TEXT NOT NULL,
    description TEXT,
    source_disk_uid TEXT NOT NULL,
    destination_disk_uid TEXT NULL,
    scheduled_time INTEGER NULL,
    created_on INTEGER NOT NULL,
    updated_on INTEGER NOT NULL,
    completed_on INTEGER NULL,
    process_id INTEGER NULL,
    payload TEXT NULL,
    progress_percent INTEGER DEFAULT 0,
    error_message TEXT NULL,
    files_processed INTEGER DEFAULT 0,
    bytes_processed INTEGER DEFAULT 0,
    estimated_duration INTEGER NULL,
    depends_on_task_uid TEXT NULL,
    FOREIGN KEY (source_disk_uid) REFERENCES disks(uid),
    FOREIGN KEY (destination_disk_uid) REFERENCES disks(uid),
    FOREIGN KEY (depends_on_task_uid) REFERENCES tasks(uid)
);
```

### Go Backend Components
- **Task Engine Service** (`internal/service/taskengine/`)
  - `engine.go` - Core task engine with worker pool
  - `scheduler.go` - Priority scheduling and opportunistic logic
  - `recovery.go` - Startup recovery and stale task handling
  - `types.go` - Task definitions and interfaces

- **Task Repository** (`internal/store/task/`)
  - `repository.go` - GORM-based task persistence
  - `queries.go` - Optimized task queries

- **Task API** (`internal/api/tasks/`)
  - `handlers.go` - HTTP handlers for task endpoints
  - `middleware.go` - Task-specific middleware

### Task Types & Interfaces
```go
type TaskType string

const (
    TaskTypeScanDisk     TaskType = "scan_disk"
    TaskTypeMoveFiles    TaskType = "move_files" 
    TaskTypeCalculateMD5 TaskType = "calculate_md5"
    TaskTypeScanMediaInfo TaskType = "scan_mediainfo"
    TaskTypeDeleteFiles  TaskType = "delete_files"
)

type ExecutionPriority string

const (
    PriorityImmediate    ExecutionPriority = "immediate"
    PriorityOpportunistic ExecutionPriority = "opportunistic"
    PriorityScheduled    ExecutionPriority = "scheduled"
)

type TaskExecutor interface {
    Execute(ctx context.Context, task *Task) error
    CanExecute(task *Task) bool
    EstimateDuration(task *Task) time.Duration
}
```

### Configuration
- `MAX_CONCURRENT_TASKS` (default: 3)
- `TASK_TIMEOUT_HOURS` (default: 24)  
- `OPPORTUNISTIC_CHECK_INTERVAL` (default: 30s)
- `STALE_TASK_THRESHOLD` (default: 1h)

## Validation & Testing

### Unit Tests
- [ ] Task creation and validation logic
- [ ] Priority queue ordering and execution
- [ ] Dependency resolution and scheduling
- [ ] Error handling and recovery scenarios
- [ ] Worker pool management and concurrency

### Integration Tests  
- [ ] Full task lifecycle (create → execute → complete)
- [ ] Task cancellation during execution
- [ ] System recovery with stale tasks
- [ ] Database persistence and querying
- [ ] API endpoint functionality

### Performance Tests
- [ ] Concurrent task execution under load
- [ ] Memory usage with large task queues
- [ ] Database performance with many tasks
- [ ] Task startup and recovery time

## Dependencies

**Required Stories:**
- Story 1.1: Application configuration system
- Story 1.2: Disk discovery and registration  
- Story 1.3: File system scanning (for disk status)

**Database Dependencies:**
- V4 tasks table (already defined in architecture)
- V4 disks table (for disk status references)

## Definition of Done

- [ ] Task engine can create and execute all five task types
- [ ] Three execution priorities work correctly (immediate, opportunistic, scheduled)
- [ ] System recovery properly handles stale tasks on startup
- [ ] All API endpoints implemented and tested
- [ ] Worker pool manages concurrent execution safely
- [ ] Task dependencies resolve correctly
- [ ] Progress tracking updates during execution
- [ ] Error handling provides useful diagnostic information
- [ ] Performance meets requirements (3 concurrent tasks, <1s startup)
- [ ] Integration tests pass for all critical paths
- [ ] Documentation includes API reference and configuration guide

## Success Metrics

- **Reliability:** Zero task corruption or data loss
- **Performance:** Task startup < 1 second, recovery < 5 seconds  
- **Concurrency:** Support 3+ concurrent tasks without issues
- **Scalability:** Handle 1000+ queued tasks without performance degradation
- **Recovery:** 100% success rate for detecting and handling stale tasks

## Next Stories

This foundation enables:
- **Story 2.2:** MD5 Checksum Background Processing
- **Story 2.3:** MediaInfo Data Background Processing  
- **Story 2.4:** Task Queue Management UI
- **Story 2.5:** Opportunistic Task Execution Logic
- **Story 2.6:** Advanced Task Scheduling
