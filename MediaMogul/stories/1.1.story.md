# Story: Application Bootstrap and Configuration

## Status: Approved

## Story

As a system administrator,
I want to configure MediaMogul with my disk paths and settings,
so that the application knows which disks to monitor and how to operate.

## Acceptance Criteria

### Application Bootstrap
- [ ] Application starts successfully with default configuration
- [ ] Web interface accessible at http://localhost:8080
- [ ] Configuration persists between application restarts
- [ ] Basic error handling for invalid paths or permissions

### Physical Disk Discovery
- [ ] Physical disks detected at startup using partition GUID as primary identifier
- [ ] Serial numbers collected when available as secondary identification
- [ ] Disk uniqueness determined by GUID + serial_number combination for change detection
- [ ] By default, all detected disks are automatically enabled for monitoring
- [ ] Auto-monitoring behavior can be disabled via configuration setting

### Disk Monitoring Management
- [ ] Configuration page displays all detected disks with their current monitoring status
- [ ] Users can disable monitoring for individual disks via toggle/checkbox
- [ ] Disabling a disk prevents: data migrations to/from that disk, file/folder discovery on that disk
- [ ] Users can re-enable previously disabled disks
- [ ] Re-enabling a disk automatically queues a full disk scan task for that disk and its path
- [ ] Configuration includes user-friendly disk aliases for each disk

## Dev Notes

### Previous Story Insights
No previous stories - this is the foundation story.

### Data Models
**MonitoredPath Model** [Source: architecture.md#Data Models]
- Purpose: Represents a top-level path that the user has configured for monitoring
- Key Attributes: `id`, `path`
- Database Table: `monitored_paths` with `id TEXT PRIMARY KEY, path TEXT NOT NULL UNIQUE`

**PhysicalDisk Model** [Source: architecture.md#Data Models]
- Purpose: Represents a unique piece of hardware associated with a monitored path
- Key Attributes: `id`, `path_id`, `unique_id`, `file_system`, `total_space`, `first_seen_ts`, `last_seen_ts`
- Additional Attributes Needed: 
  - `partition_guid TEXT NOT NULL` - Primary unique identifier (always available)
  - `serial_number TEXT` - Optional hardware serial (may not exist on all disks)
  - `is_monitoring_enabled BOOLEAN DEFAULT true` - User monitoring preference
  - `alias TEXT` - User-friendly disk name
- Database Table: `physical_disks` with hardware identification and monitoring status
- Uniqueness Strategy: Disk identity determined by `partition_guid + serial_number` combination
- Future Enhancement: SMART monitoring data collection (post-launch feature)

### API Specifications
**Configuration API Endpoints** [Source: Epic 1 Technical Tasks]
- GET /api/v1/config - Retrieve current configuration including auto-monitoring settings
- POST /api/v1/config - Save configuration changes
- GET /api/v1/disks - Retrieve all detected disks with monitoring status and metadata
- POST /api/v1/disks/{id}/toggle - Enable/disable monitoring for specific disk
- POST /api/v1/disks/{id}/alias - Update user-friendly alias for disk
- Required for monitored paths and disk management

### Component Specifications
**Configuration UI Components** [Source: Epic 1 Technical Tasks]
- Configuration page with general settings (auto-monitoring toggle)
- Disk management section displaying all detected disks in a list/grid
- Individual disk cards showing: alias, path, size, monitoring status, enable/disable toggle
- Disk alias editing capability (inline or modal)
- Visual indicators for disk status (monitoring enabled/disabled, scan progress)
- React components with Tailwind CSS styling [Source: architecture.md#Tech Stack]

### File Locations
**Backend Structure** [Source: architecture.md#Unified Project Structure]
- Configuration storage: `apps/backend/internal/store/`
- API endpoints: `apps/backend/internal/api/`
- Service logic: `apps/backend/internal/service/`
- Main server: `apps/backend/cmd/server/main.go`

**Frontend Structure** [Source: architecture.md#Unified Project Structure]
- Configuration UI: `apps/frontend/app/`
- Shared types: `packages/shared-types/index.ts`

### Technical Constraints
**Database Technology**: SQLite for configuration persistence [Source: architecture.md#Tech Stack]
**Web Framework**: Gin for Go backend API [Source: architecture.md#Tech Stack]
**Frontend Framework**: Next.js with TypeScript [Source: architecture.md#Tech Stack]
**Port Configuration**: Backend on 8080, Frontend on 3000 [Source: Epic 1 Acceptance Criteria]

### Testing Requirements
**Backend Testing**: Go testing framework, unit tests for configuration logic [Source: architecture.md#Tech Stack]
**Frontend Testing**: Jest & RTL for component testing [Source: architecture.md#Tech Stack]
**Integration Testing**: API endpoint testing for configuration persistence

### Future Enhancements (Post-Launch)
**SMART Monitoring Integration**: 
- Collect disk health data using smartmontools at configurable intervals
- Store SMART attributes (temperature, power cycles, reallocated sectors, etc.)
- Alert users to potential disk failures based on SMART thresholds
- Historical trending of disk health metrics
- Integration with disk power management (avoid waking sleeping disks for SMART queries)

## Tasks / Subtasks

### Backend Implementation - Database & Models
- [ ] Set up SQLite database connection and migrations [Source: architecture.md#Database Schema]
- [ ] Create MonitoredPath model with GORM [Source: architecture.md#Data Models]
- [ ] Create PhysicalDisk model with required fields: partition_guid (NOT NULL), serial_number (nullable), is_monitoring_enabled, alias
- [ ] Add database migration for physical_disks table with proper constraints and indexes
- [ ] Add unique constraint on partition_guid for disk identification

### Backend Implementation - Disk Discovery Service
- [ ] Implement disk discovery service using system calls (lsblk for partition GUID, blkid for additional metadata)
- [ ] Create service to detect partition GUID as primary identifier (always required)
- [ ] Create service to detect serial numbers when available (optional field)
- [ ] Implement disk uniqueness logic using GUID + serial_number combination
- [ ] Implement auto-monitoring logic (enable new disks by default)
- [ ] Add disk metadata collection (size, filesystem, mount points)
- [ ] Write unit tests for disk discovery, identification, and uniqueness detection logic

### Backend Implementation - Configuration API
- [ ] Create GET /api/v1/config endpoint for configuration and auto-monitoring settings
- [ ] Create POST /api/v1/config endpoint to save configuration changes
- [ ] Create GET /api/v1/disks endpoint to list all detected disks with status
- [ ] Create POST /api/v1/disks/{id}/toggle endpoint to enable/disable monitoring
- [ ] Create POST /api/v1/disks/{id}/alias endpoint for disk alias management
- [ ] Add error handling for invalid operations and disk access issues
- [ ] Write unit tests for all configuration and disk management endpoints

### Frontend Implementation - Configuration UI
- [ ] Create configuration page component with Next.js [Source: architecture.md#Unified Project Structure]
- [ ] Implement general settings section (auto-monitoring toggle)
- [ ] Create disk management section with list/grid of detected disks
- [ ] Implement individual disk cards with status, toggle, and alias editing
- [ ] Add visual indicators for monitoring status and disk states
- [ ] Add loading states and success/error feedback for disk operations
- [ ] Style components with Tailwind CSS [Source: architecture.md#Tech Stack]
- [ ] Write component tests with Jest & RTL

### Integration & Quality
- [ ] Test application startup with automatic disk discovery
- [ ] Verify auto-monitoring behavior for newly detected disks
- [ ] Test disk enable/disable functionality and state persistence
- [ ] Verify that re-enabling queues disk scan task (integration with task system)
- [ ] Test configuration persistence across application restarts
- [ ] Ensure web interface accessibility at localhost:8080
- [ ] Test error scenarios (disk access issues, invalid operations)
- [ ] Validate all API integrations between frontend and backend

## Definition of Done

- Physical disks automatically detected at startup using hardware identifiers
- All detected disks enabled for monitoring by default (configurable)
- Users can disable/enable monitoring for individual disks via configuration page
- Disk aliases can be set and persist between restarts
- Re-enabling a disabled disk automatically queues a full scan task
- Configuration changes persist between application restarts
- Web interface accessible and responsive at localhost:8080
- All tests pass (unit, integration, component)
- No critical bugs or crashes during disk discovery and configuration workflows

## File List

*To be populated during implementation*

## Dev Agent Record

### Implementation Notes
*To be populated during development*

### Completion Notes
*To be populated upon completion*

### Debug Log References
*To be populated if debugging required*

## QA Results

*To be populated during QA review*
