# Story: Physical Disk Discovery and Registration

## Status: Approved

## Story

As a user,
I want MediaMogul to automatically detect and register my physical disks,
so that I can see disk-level information and status.

## Acceptance Criteria

### Disk Discovery & Registration
- [ ] System discovers physical disks on startup
- [ ] Disk information includes: device path, mount point, total/used/available space
- [ ] Disk power status detection (active/standby/sleep) using smartctl
- [ ] Disk registration persists in database with unique identification
- [ ] Manual disk refresh capability available

### Hardware Identification & Persistence
- [ ] Each disk identified by partition GUID as primary identifier
- [ ] Serial numbers collected when available as secondary identification
- [ ] Disk uniqueness determined by GUID + serial_number combination
- [ ] First seen and last seen timestamps tracked for each disk
- [ ] Graceful handling of unmounted or unavailable disks

### Integration with Configuration System
- [ ] Discovered disks integrate with monitoring configuration from Story 1.1
- [ ] Disk aliases from configuration system applied to discovered disks
- [ ] Monitoring status persists and applies to discovered disk data

## Dev Notes

### Previous Story Insights
**From Story 1.1 - Application Bootstrap and Configuration:**
- PhysicalDisk model design established with partition_guid (NOT NULL) and serial_number (nullable)
- Disk monitoring enable/disable functionality already planned
- User alias functionality already specified
- Database schema foundation established

### Data Models
**PhysicalDisk Model** [Source: architecture.md#Data Models + Story 1.1]
- Purpose: Represents a unique piece of hardware associated with a monitored path
- Key Attributes: `id`, `path_id`, `unique_id`, `file_system`, `total_space`, `first_seen_ts`, `last_seen_ts`
- Enhanced Attributes from Story 1.1:
  - `partition_guid TEXT NOT NULL` - Primary unique identifier
  - `serial_number TEXT` - Optional hardware serial
  - `device_path TEXT` - System device path (e.g., /dev/sda1)
  - `mount_point TEXT` - Current mount point if mounted
  - `power_status TEXT` - Current power state (active/standby/sleep)
  - `total_space INTEGER` - Total disk capacity in bytes
  - `used_space INTEGER` - Currently used space in bytes
  - `available_space INTEGER` - Available space in bytes
- Database Table: `physical_disks` with hardware identification

### API Specifications
**Disk Discovery API Endpoints** [Source: Epic 1 Technical Tasks]
- GET /api/v1/disks/discover - Trigger manual disk discovery/refresh
- GET /api/v1/disks/{id}/status - Get detailed disk status including power state
- POST /api/v1/disks/refresh - Refresh disk information for all or specific disks
- Integration with existing /api/v1/disks endpoint from Story 1.1

### Component Specifications
**Disk Information Display** [Source: Epic 1 Technical Tasks]
- Disk status indicators showing power state (active/sleep/unavailable)
- Disk space visualization (used/available space)
- Device path and mount point information display
- Integration with disk management UI from Story 1.1
- Real-time disk status updates

### File Locations
**Backend Structure** [Source: architecture.md#Unified Project Structure]
- Disk discovery service: `apps/backend/internal/service/discovery.go`
- Power status service: `apps/backend/internal/service/power.go`
- Disk model extensions: `apps/backend/internal/models/`
- API endpoints: `apps/backend/internal/api/disks.go`

**System Integration**
- smartctl integration for power status detection
- System calls for disk discovery (lsblk, blkid, df)
- Mount point detection and monitoring

### Technical Constraints
**Power Management**: Must not wake sleeping disks during discovery [Source: architecture.md NFR1]
**System Dependencies**: Requires smartctl binary in host environment [Source: architecture.md NFR4]
**Performance**: Discovery operations should be efficient and non-blocking
**Error Handling**: Graceful handling of unmounted, encrypted, or inaccessible disks

### Testing Requirements
**Backend Testing**: Unit tests for disk discovery logic, power status detection, error scenarios
**Integration Testing**: System-level disk discovery with various disk configurations
**Mocking**: Mock system calls for consistent testing across environments

## Tasks / Subtasks

### Backend Implementation - Disk Discovery Service
- [ ] Implement disk discovery service using system calls (lsblk, blkid, df)
- [ ] Create partition GUID detection service as primary identifier
- [ ] Create serial number detection service (optional, when available)
- [ ] Implement disk space calculation (total, used, available)
- [ ] Add mount point detection and tracking
- [ ] Write unit tests for discovery logic with mock system calls

### Backend Implementation - Power Status Integration
- [ ] Integrate smartctl for power status detection (active/standby/sleep)
- [ ] Implement power status caching to avoid frequent smartctl calls
- [ ] Add error handling for disks without smart capabilities
- [ ] Create power status update service for periodic checks
- [ ] Write unit tests for power status detection with various disk types

### Backend Implementation - Database Operations
- [ ] Extend PhysicalDisk model with new fields (device_path, mount_point, power_status, space fields)
- [ ] Implement disk registration with uniqueness checking (GUID + serial)
- [ ] Add first_seen_ts and last_seen_ts tracking
- [ ] Create database operations for disk updates and status changes
- [ ] Add database migration for new disk fields

### Backend Implementation - API Endpoints
- [ ] Create GET /api/v1/disks/discover endpoint for manual discovery
- [ ] Create GET /api/v1/disks/{id}/status endpoint for detailed disk status
- [ ] Create POST /api/v1/disks/refresh endpoint for refresh operations
- [ ] Extend existing /api/v1/disks endpoint with discovered disk information
- [ ] Add error handling for unavailable disks and system call failures
- [ ] Write unit tests for all disk discovery and status endpoints

### Frontend Implementation - Disk Status Display
- [ ] Create disk status indicator components (power state, availability)
- [ ] Implement disk space visualization components (progress bars, charts)
- [ ] Add device path and mount point display to disk cards
- [ ] Create manual refresh button and loading states
- [ ] Integrate with existing disk management UI from Story 1.1
- [ ] Add error states for unavailable or problematic disks
- [ ] Write component tests for disk status displays

### Integration & Quality
- [ ] Test automatic disk discovery on application startup
- [ ] Verify disk persistence and uniqueness detection across restarts
- [ ] Test manual refresh functionality and UI updates
- [ ] Verify power status detection for various disk types and states
- [ ] Test graceful handling of unmounted, encrypted, or inaccessible disks
- [ ] Test integration with monitoring configuration from Story 1.1
- [ ] Validate disk space calculations and display accuracy
- [ ] Test error scenarios (missing smartctl, permission issues, system call failures)

## Definition of Done

- Physical disks automatically discovered and registered on startup
- Disk information persists in database with unique identification (GUID + serial)
- Disk space and power status accurately reported and displayed
- Manual refresh functionality works reliably
- Unavailable disks handled gracefully with appropriate error messages
- Integration with disk monitoring configuration from Story 1.1 functions correctly
- All tests pass (unit, integration, component)
- No critical bugs or crashes during disk discovery operations

## File List

*To be populated during implementation*

## Dev Agent Record

### Implementation Notes
*To be populated during development*

### Completion Notes
*To be populated upon completion*

### Debug Log References
*To be populated if debugging required*

## QA Results

*To be populated during QA review*
